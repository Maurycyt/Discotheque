%--------------------------------------------------------------------------
% File     : SET001-0 : TPTP v9.0.0. Released v1.0.0.
% Domain   : Set Theory
% Axioms   : Membership and subsets
% Version  : [LS74] axioms.
% English  :

% Refs     : [LS74]  Lawrence & Starkey (1974), Experimental tests of resol
% Source   : [SPRFN]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of clauses     :    6 (   0 unt;   1 nHn;   5 RR)
%            Number of literals    :   14 (   0 equ;   7 neg)
%            Maximal clause size   :    3 (   2 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    3 (   3 usr;   0 prp; 2-2 aty)
%            Number of functors    :    1 (   1 usr;   0 con; 2-2 aty)
%            Number of variables   :   13 (   0 sgn)
% SPC      : 

% Comments :
%--------------------------------------------------------------------------
cnf(membership_in_subsets,axiom,
    ( ~ member(Element,Subset)
    | ~ subset(Subset,Superset)
    | member(Element,Superset) ) ).

cnf(subsets_axiom1,axiom,
    ( subset(Subset,Superset)
    | member(member_of_1_not_of_2(Subset,Superset),Subset) ) ).

cnf(subsets_axiom2,axiom,
    ( ~ member(member_of_1_not_of_2(Subset,Superset),Superset)
    | subset(Subset,Superset) ) ).

cnf(set_equal_sets_are_subsets1,axiom,
    ( ~ equal_sets(Subset,Superset)
    | subset(Subset,Superset) ) ).

cnf(set_equal_sets_are_subsets2,axiom,
    ( ~ equal_sets(Superset,Subset)
    | subset(Subset,Superset) ) ).

cnf(subsets_are_set_equal_sets,axiom,
    ( ~ subset(Set1,Set2)
    | ~ subset(Set2,Set1)
    | equal_sets(Set2,Set1) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET001-1 : TPTP v9.0.0. Released v1.0.0.
% Domain   : Set Theory
% Axioms   : Membership and union
% Version  : [LS74] axioms.
% English  :

% Refs     : [LS74]  Lawrence & Starkey (1974), Experimental tests of resol
% Source   : [SPRFN]
% Names    : Problem 118 [LS74]

% Status   : Satisfiable
% Syntax   : Number of clauses     :    6 (   0 unt;   2 nHn;   5 RR)
%            Number of literals    :   20 (   0 equ;  10 neg)
%            Maximal clause size   :    4 (   3 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    2 (   2 usr;   0 prp; 2-3 aty)
%            Number of functors    :    1 (   1 usr;   0 con; 3-3 aty)
%            Number of variables   :   21 (   2 sgn)
% SPC      : 

% Comments : Requires SET001-0.ax
%--------------------------------------------------------------------------
cnf(member_of_union_is_member_of_one_set,axiom,
    ( ~ union(Set1,Set2,Union)
    | ~ member(Element,Union)
    | member(Element,Set1)
    | member(Element,Set2) ) ).

cnf(member_of_set1_is_member_of_union,axiom,
    ( ~ union(Set1,Set2,Union)
    | ~ member(Element,Set1)
    | member(Element,Union) ) ).

cnf(member_of_set2_is_member_of_union,axiom,
    ( ~ union(Set1,Set2,Union)
    | ~ member(Element,Set2)
    | member(Element,Union) ) ).

cnf(union_axiom1,axiom,
    ( union(Set1,Set2,Union)
    | member(g(Set1,Set2,Union),Set1)
    | member(g(Set1,Set2,Union),Set2)
    | member(g(Set1,Set2,Union),Union) ) ).

cnf(union_axiom2,axiom,
    ( ~ member(g(Set1,Set2,Union),Set1)
    | ~ member(g(Set1,Set2,Union),Union)
    | union(Set1,Set2,Union) ) ).

cnf(union_axiom3,axiom,
    ( ~ member(g(Set1,Set2,Union),Set2)
    | ~ member(g(Set1,Set2,Union),Union)
    | union(Set1,Set2,Union) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET001-2 : TPTP v9.0.0. Released v1.0.0.
% Domain   : Set Theory
% Axioms   : Membership and intersection
% Version  : [LS74] axioms.
% English  :

% Refs     : [LS74]  Lawrence & Starkey (1974), Experimental tests of resol
% Source   : [SPRFN]
% Names    : Problem 118 [LS74]

% Status   : Satisfiable
% Syntax   : Number of clauses     :    6 (   0 unt;   2 nHn;   4 RR)
%            Number of literals    :   20 (   0 equ;  10 neg)
%            Maximal clause size   :    4 (   3 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    2 (   2 usr;   0 prp; 2-3 aty)
%            Number of functors    :    1 (   1 usr;   0 con; 3-3 aty)
%            Number of variables   :   21 (   2 sgn)
% SPC      : 

% Comments : Requires SET001-0.ax
%--------------------------------------------------------------------------
cnf(member_of_intersection_is_member_of_set1,axiom,
    ( ~ intersection(Set1,Set2,Intersection)
    | ~ member(Element,Intersection)
    | member(Element,Set1) ) ).

cnf(member_of_intersection_is_member_of_set2,axiom,
    ( ~ intersection(Set1,Set2,Intersection)
    | ~ member(Element,Intersection)
    | member(Element,Set2) ) ).

cnf(member_of_both_is_member_of_intersection,axiom,
    ( ~ intersection(Set1,Set2,Intersection)
    | ~ member(Element,Set2)
    | ~ member(Element,Set1)
    | member(Element,Intersection) ) ).

cnf(intersection_axiom1,axiom,
    ( member(h(Set1,Set2,Intersection),Intersection)
    | intersection(Set1,Set2,Intersection)
    | member(h(Set1,Set2,Intersection),Set1) ) ).

cnf(intersection_axiom2,axiom,
    ( member(h(Set1,Set2,Intersection),Intersection)
    | intersection(Set1,Set2,Intersection)
    | member(h(Set1,Set2,Intersection),Set2) ) ).

cnf(intersection_axiom3,axiom,
    ( ~ member(h(Set1,Set2,Intersection),Intersection)
    | ~ member(h(Set1,Set2,Intersection),Set2)
    | ~ member(h(Set1,Set2,Intersection),Set1)
    | intersection(Set1,Set2,Intersection) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET001-3 : TPTP v9.0.0. Released v1.0.0.
% Domain   : Set Theory
% Axioms   : Membership and difference
% Version  : [LS74] axioms.
% English  :

% Refs     : [LS74]  Lawrence & Starkey (1974), Experimental tests of resol
% Source   : [SPRFN]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of clauses     :    6 (   0 unt;   4 nHn;   5 RR)
%            Number of literals    :   20 (   0 equ;  10 neg)
%            Maximal clause size   :    4 (   3 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    2 (   2 usr;   0 prp; 2-3 aty)
%            Number of functors    :    1 (   1 usr;   0 con; 3-3 aty)
%            Number of variables   :   21 (   2 sgn)
% SPC      : 

% Comments : Requires SET001-0.ax
%--------------------------------------------------------------------------
cnf(member_of_difference,axiom,
    ( ~ difference(Set1,Set2,Difference)
    | ~ member(Element,Difference)
    | member(Element,Set1) ) ).

cnf(not_member_of_difference,axiom,
    ( ~ member(Element,Set1)
    | ~ member(Element,Set2)
    | ~ difference(A_set,Set1,Set2) ) ).

cnf(member_of_difference_or_set2,axiom,
    ( ~ member(Element,Set1)
    | ~ difference(Set1,Set2,Difference)
    | member(Element,Difference)
    | member(Element,Set2) ) ).

cnf(difference_axiom2,axiom,
    ( difference(Set1,Set2,Difference)
    | member(k(Set1,Set2,Difference),Set1)
    | member(k(Set1,Set2,Difference),Difference) ) ).

cnf(difference_axiom1,axiom,
    ( ~ member(k(Set1,Set2,Difference),Set2)
    | member(k(Set1,Set2,Difference),Difference)
    | difference(Set1,Set2,Difference) ) ).

cnf(difference_axiom3,axiom,
    ( ~ member(k(Set1,Set2,Difference),Difference)
    | ~ member(k(Set1,Set2,Difference),Set1)
    | member(k(Set1,Set2,Difference),Set2)
    | difference(Set1,Set2,Difference) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET002-0 : TPTP v9.0.0. Released v1.0.0.
% Domain   : Set Theory
% Axioms   : Set theory axioms
% Version  : [MOW76] axioms : Biased.
% English  :

% Refs     : [MOW76] McCharen et al. (1976), Problems and Experiments for a
% Source   : [ANL]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of clauses     :   21 (   3 unt;   3 nHn;  15 RR)
%            Number of literals    :   45 (   0 equ;  23 neg)
%            Maximal clause size   :    3 (   2 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    4 (   4 usr;   0 prp; 2-2 aty)
%            Number of functors    :    5 (   5 usr;   1 con; 0-2 aty)
%            Number of variables   :   48 (   5 sgn)
% SPC      : 

% Comments :
%--------------------------------------------------------------------------
%-----Definition of the empty set.
cnf(empty_set,axiom,
    ~ member(X,empty_set) ).

%-----Subset axioms. These are the same as in SET001-0.ax
cnf(membership_in_subsets,axiom,
    ( ~ member(Element,Subset)
    | ~ subset(Subset,Superset)
    | member(Element,Superset) ) ).

cnf(subsets_axiom1,axiom,
    ( subset(Subset,Superset)
    | member(member_of_1_not_of_2(Subset,Superset),Subset) ) ).

cnf(subsets_axiom2,axiom,
    ( ~ member(member_of_1_not_of_2(Subset,Superset),Superset)
    | subset(Subset,Superset) ) ).

%-----Axioms of complementation.
cnf(member_of_set_or_complement,axiom,
    ( member(X,Xs)
    | member(X,complement(Xs)) ) ).

cnf(not_member_of_set_and_complement,axiom,
    ( ~ member(X,Xs)
    | ~ member(X,complement(Xs)) ) ).

%-----Axioms of union.
cnf(member_of_set1_is_member_of_union,axiom,
    ( ~ member(X,Xs)
    | member(X,union(Xs,Ys)) ) ).

cnf(member_of_set2_is_member_of_union,axiom,
    ( ~ member(X,Ys)
    | member(X,union(Xs,Ys)) ) ).

cnf(member_of_union_is_member_of_one_set,axiom,
    ( ~ member(X,union(Xs,Ys))
    | member(X,Xs)
    | member(X,Ys) ) ).

%-----Axioms of intersection.
cnf(member_of_both_is_member_of_intersection,axiom,
    ( ~ member(X,Xs)
    | ~ member(X,Ys)
    | member(X,intersection(Xs,Ys)) ) ).

cnf(member_of_intersection_is_member_of_set1,axiom,
    ( ~ member(X,intersection(Xs,Ys))
    | member(X,Xs) ) ).

cnf(member_of_intersection_is_member_of_set2,axiom,
    ( ~ member(X,intersection(Xs,Ys))
    | member(X,Ys) ) ).

%-----Set equality axioms.
cnf(set_equal_sets_are_subsets1,axiom,
    ( ~ equal_sets(Subset,Superset)
    | subset(Subset,Superset) ) ).

cnf(set_equal_sets_are_subsets2,axiom,
    ( ~ equal_sets(Superset,Subset)
    | subset(Subset,Superset) ) ).

cnf(subsets_are_set_equal_sets,axiom,
    ( ~ subset(Set1,Set2)
    | ~ subset(Set2,Set1)
    | equal_sets(Set2,Set1) ) ).

%-----Equality axioms.
cnf(reflexivity_for_set_equal,axiom,
    equal_sets(Xs,Xs) ).

cnf(symmetry_for_set_equal,axiom,
    ( ~ equal_sets(Xs,Ys)
    | equal_sets(Ys,Xs) ) ).

cnf(transitivity_for_set_equal,axiom,
    ( ~ equal_sets(Xs,Ys)
    | ~ equal_sets(Ys,Zs)
    | equal_sets(Xs,Zs) ) ).

cnf(reflexivity_for_equal_elements,axiom,
    equal_elements(X,X) ).

cnf(symmetry_for_equal_elements,axiom,
    ( ~ equal_elements(X,Y)
    | equal_elements(Y,X) ) ).

cnf(transitivity_for_equal_elements,axiom,
    ( ~ equal_elements(X,Y)
    | ~ equal_elements(Y,Z)
    | equal_elements(X,Z) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET003-0 : TPTP v9.0.0. Released v1.0.0.
% Domain   : Set Theory
% Axioms   : Set theory axioms based on Godel set theory
% Version  : [BL+86] axioms.
% English  :

% Refs     : [BL+86] Boyer et al. (1986), Set Theory in First-Order Logic:
%          : [Wos88] Wos (1988), Automated Reasoning - 33 Basic Research Pr
%          : [McC92] McCune (1992), Email to G. Sutcliffe
% Source   : [McC92]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of clauses     :  141 (  11 unt;  20 nHn; 118 RR)
%            Number of literals    :  355 (  47 equ; 197 neg)
%            Maximal clause size   :    8 (   2 avg)
%            Maximal term depth    :    4 (   1 avg)
%            Number of predicates  :   14 (  13 usr;   0 prp; 1-5 aty)
%            Number of functors    :   59 (  59 usr;   6 con; 0-5 aty)
%            Number of variables   :  320 (  28 sgn)
% SPC      : 

% Comments : Requires EQU001-0.ax
%          : These axioms are based on Godel's axioms for set theory.
%          : These axioms are also used in [Wos88] p.225.
%--------------------------------------------------------------------------
%----Axiom A-1, little sets are sets (omitted because all objects are sets)

%----Axiom A-2, elements of sets are little sets.
cnf(a2,axiom,
    ( ~ member(X,Y)
    | little_set(X) ) ).

%----Axiom A-3, principle of extensionality
cnf(extensionality1,axiom,
    ( little_set(f1(X,Y))
    | X = Y ) ).

cnf(extensionality2,axiom,
    ( member(f1(X,Y),X)
    | member(f1(X,Y),Y)
    | X = Y ) ).

cnf(extensionality3,axiom,
    ( ~ member(f1(X,Y),X)
    | ~ member(f1(X,Y),Y)
    | X = Y ) ).

%----Axiom a-4, existence of nonordered pair
cnf(non_ordered_pair1,axiom,
    ( ~ member(U,non_ordered_pair(X,Y))
    | U = X
    | U = Y ) ).

cnf(non_ordered_pair2,axiom,
    ( member(U,non_ordered_pair(X,Y))
    | ~ little_set(U)
    | U != X ) ).

cnf(non_ordered_pair3,axiom,
    ( member(U,non_ordered_pair(X,Y))
    | ~ little_set(U)
    | U != Y ) ).

cnf(non_ordered_pair4,axiom,
    little_set(non_ordered_pair(X,Y)) ).

%----Definition of singleton set
cnf(singleton_set,axiom,
    singleton_set(X) = non_ordered_pair(X,X) ).

%----Definition of ordered pair
cnf(ordered_pair,axiom,
    ordered_pair(X,Y) = non_ordered_pair(singleton_set(X),non_ordered_pair(X,Y)) ).

%----Definition of ordered pair predicate
cnf(ordered_pair_predicate1,axiom,
    ( ~ ordered_pair_predicate(X)
    | little_set(f2(X)) ) ).

cnf(ordered_pair_predicate2,axiom,
    ( ~ ordered_pair_predicate(X)
    | little_set(f3(X)) ) ).

cnf(ordered_pair_predicate3,axiom,
    ( ~ ordered_pair_predicate(X)
    | X = ordered_pair(f2(X),f3(X)) ) ).

cnf(ordered_pair_predicate4,axiom,
    ( ordered_pair_predicate(X)
    | ~ little_set(Y)
    | ~ little_set(Z)
    | X != ordered_pair(Y,Z) ) ).

%----Axiom of first
cnf(first1,axiom,
    ( ~ member(Z,first(X))
    | little_set(f4(Z,X)) ) ).

cnf(first2,axiom,
    ( ~ member(Z,first(X))
    | little_set(f5(Z,X)) ) ).

cnf(first3,axiom,
    ( ~ member(Z,first(X))
    | X = ordered_pair(f4(Z,X),f5(Z,X)) ) ).

cnf(first4,axiom,
    ( ~ member(Z,first(X))
    | member(Z,f4(Z,X)) ) ).

cnf(first5,axiom,
    ( member(Z,first(X))
    | ~ little_set(U)
    | ~ little_set(V)
    | X != ordered_pair(U,V)
    | ~ member(Z,U) ) ).

%----Axiom of second
cnf(second1,axiom,
    ( ~ member(Z,second(X))
    | little_set(f6(Z,X)) ) ).

cnf(second2,axiom,
    ( ~ member(Z,second(X))
    | little_set(f7(Z,X)) ) ).

cnf(second3,axiom,
    ( ~ member(Z,second(X))
    | X = ordered_pair(f6(Z,X),f7(Z,X)) ) ).

cnf(second4,axiom,
    ( ~ member(Z,second(X))
    | member(Z,f7(Z,X)) ) ).

cnf(second5,axiom,
    ( member(Z,second(X))
    | ~ little_set(U)
    | ~ little_set(V)
    | X != ordered_pair(U,V)
    | ~ member(Z,V) ) ).

%----Axiom B-1, element relation
cnf(element_relation1,axiom,
    ( ~ member(Z,estin)
    | ordered_pair_predicate(Z) ) ).

cnf(element_relation2,axiom,
    ( ~ member(Z,estin)
    | member(first(Z),second(Z)) ) ).

cnf(element_relation3,axiom,
    ( member(Z,estin)
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Z)
    | ~ member(first(Z),second(Z)) ) ).

%----Axiom B-2, intersection
cnf(intersection1,axiom,
    ( ~ member(Z,intersection(X,Y))
    | member(Z,X) ) ).

cnf(intersection2,axiom,
    ( ~ member(Z,intersection(X,Y))
    | member(Z,Y) ) ).

cnf(intersection3,axiom,
    ( member(Z,intersection(X,Y))
    | ~ member(Z,X)
    | ~ member(Z,Y) ) ).

%----Axiom B-3, complement
cnf(complement1,axiom,
    ( ~ member(Z,complement(X))
    | ~ member(Z,X) ) ).

cnf(complement2,axiom,
    ( member(Z,complement(X))
    | ~ little_set(Z)
    | member(Z,X) ) ).

%----Definition of union
cnf(union,axiom,
    union(X,Y) = complement(intersection(complement(X),complement(Y))) ).

%----Axiom B-4, domain
cnf(domain1,axiom,
    ( ~ member(Z,domain_of(X))
    | ordered_pair_predicate(f8(Z,X)) ) ).

cnf(domain2,axiom,
    ( ~ member(Z,domain_of(X))
    | member(f8(Z,X),X) ) ).

cnf(domain3,axiom,
    ( ~ member(Z,domain_of(X))
    | Z = first(f8(Z,X)) ) ).

cnf(domain4,axiom,
    ( member(Z,domain_of(X))
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Xp)
    | ~ member(Xp,X)
    | Z != first(Xp) ) ).

%----Axiom B-5, cross product
cnf(cross_product1,axiom,
    ( ~ member(Z,cross_product(X,Y))
    | ordered_pair_predicate(Z) ) ).

cnf(cross_product2,axiom,
    ( ~ member(Z,cross_product(X,Y))
    | member(first(Z),X) ) ).

cnf(cross_product3,axiom,
    ( ~ member(Z,cross_product(X,Y))
    | member(second(Z),Y) ) ).

cnf(cross_product4,axiom,
    ( member(Z,cross_product(X,Y))
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Z)
    | ~ member(first(Z),X)
    | ~ member(second(Z),Y) ) ).

%----Axiom B-6, converse
cnf(converse1,axiom,
    ( ~ member(Z,converse(X))
    | ordered_pair_predicate(Z) ) ).

cnf(converse2,axiom,
    ( ~ member(Z,converse(X))
    | member(ordered_pair(second(Z),first(Z)),X) ) ).

cnf(converse3,axiom,
    ( member(Z,converse(X))
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Z)
    | ~ member(ordered_pair(second(Z),first(Z)),X) ) ).

%----Axiom B-7, rotate_right
cnf(rotate_right1,axiom,
    ( ~ member(Z,rotate_right(X))
    | little_set(f9(Z,X)) ) ).

cnf(rotate_right2,axiom,
    ( ~ member(Z,rotate_right(X))
    | little_set(f10(Z,X)) ) ).

cnf(rotate_right3,axiom,
    ( ~ member(Z,rotate_right(X))
    | little_set(f11(Z,X)) ) ).

cnf(rotate_right4,axiom,
    ( ~ member(Z,rotate_right(X))
    | Z = ordered_pair(f9(Z,X),ordered_pair(f10(Z,X),f11(Z,X))) ) ).

cnf(rotate_right5,axiom,
    ( ~ member(Z,rotate_right(X))
    | member(ordered_pair(f10(Z,X),ordered_pair(f11(Z,X),f9(Z,X))),X) ) ).

cnf(rotate_right6,axiom,
    ( member(Z,rotate_right(X))
    | ~ little_set(Z)
    | ~ little_set(U)
    | ~ little_set(V)
    | ~ little_set(W)
    | Z != ordered_pair(U,ordered_pair(V,W))
    | ~ member(ordered_pair(V,ordered_pair(W,U)),X) ) ).

%----Axiom B-8, flip_range
cnf(flip_range1,axiom,
    ( ~ member(Z,flip_range_of(X))
    | little_set(f12(Z,X)) ) ).

cnf(flip_range2,axiom,
    ( ~ member(Z,flip_range_of(X))
    | little_set(f13(Z,X)) ) ).

cnf(flip_range3,axiom,
    ( ~ member(Z,flip_range_of(X))
    | little_set(f14(Z,X)) ) ).

cnf(flip_range4,axiom,
    ( ~ member(Z,flip_range_of(X))
    | Z = ordered_pair(f12(Z,X),ordered_pair(f13(Z,X),f14(Z,X))) ) ).

cnf(flip_range5,axiom,
    ( ~ member(Z,flip_range_of(X))
    | member(ordered_pair(f12(Z,X),ordered_pair(f14(Z,X),f13(Z,X))),X) ) ).

cnf(flip_range6,axiom,
    ( member(Z,flip_range_of(X))
    | ~ little_set(Z)
    | ~ little_set(U)
    | ~ little_set(V)
    | ~ little_set(W)
    | Z != ordered_pair(U,ordered_pair(V,W))
    | ~ member(ordered_pair(U,ordered_pair(W,V)),X) ) ).

%----Definition of successor
cnf(successor,axiom,
    successor(X) = union(X,singleton_set(X)) ).

%----Definition of empty set
cnf(empty_set,axiom,
    ~ member(Z,empty_set) ).

%----Definition of universal set
cnf(universal_set,axiom,
    ( member(Z,universal_set)
    | ~ little_set(Z) ) ).

%----Axiom C-1, infinity
cnf(infinity1,axiom,
    little_set(infinity) ).

cnf(infinity2,axiom,
    member(empty_set,infinity) ).

cnf(infinity3,axiom,
    ( ~ member(X,infinity)
    | member(successor(X),infinity) ) ).

%----Axiom C-2, sigma (union of elements)
cnf(sigma1,axiom,
    ( ~ member(Z,sigma(X))
    | member(f16(Z,X),X) ) ).

cnf(sigma2,axiom,
    ( ~ member(Z,sigma(X))
    | member(Z,f16(Z,X)) ) ).

cnf(sigma3,axiom,
    ( member(Z,sigma(X))
    | ~ member(Y,X)
    | ~ member(Z,Y) ) ).

cnf(sigma4,axiom,
    ( ~ little_set(U)
    | little_set(sigma(U)) ) ).

%----Definition of subset
cnf(subset1,axiom,
    ( ~ subset(X,Y)
    | ~ member(U,X)
    | member(U,Y) ) ).

cnf(subset2,axiom,
    ( subset(X,Y)
    | member(f17(X,Y),X) ) ).

cnf(subset3,axiom,
    ( subset(X,Y)
    | ~ member(f17(X,Y),Y) ) ).

%----Definition of proper subset
cnf(proper_subset1,axiom,
    ( ~ proper_subset(X,Y)
    | subset(X,Y) ) ).

cnf(proper_subset2,axiom,
    ( ~ proper_subset(X,Y)
    | X != Y ) ).

cnf(proper_subset3,axiom,
    ( proper_subset(X,Y)
    | ~ subset(X,Y)
    | X = Y ) ).

%----Axiom C-3, powerset
cnf(powerset1,axiom,
    ( ~ member(Z,powerset(X))
    | subset(Z,X) ) ).

cnf(powerset2,axiom,
    ( member(Z,powerset(X))
    | ~ little_set(Z)
    | ~ subset(Z,X) ) ).

cnf(powerset3,axiom,
    ( ~ little_set(U)
    | little_set(powerset(U)) ) ).

%----Definition of relation
cnf(relation1,axiom,
    ( ~ relation(Z)
    | ~ member(X,Z)
    | ordered_pair_predicate(X) ) ).

cnf(relation2,axiom,
    ( relation(Z)
    | member(f18(Z),Z) ) ).

cnf(relation3,axiom,
    ( relation(Z)
    | ~ ordered_pair_predicate(f18(Z)) ) ).

%----Definition of single-valued set
cnf(single_valued_set1,axiom,
    ( ~ single_valued_set(X)
    | ~ little_set(U)
    | ~ little_set(V)
    | ~ little_set(W)
    | ~ member(ordered_pair(U,V),X)
    | ~ member(ordered_pair(U,W),X)
    | V = W ) ).

cnf(single_valued_set2,axiom,
    ( single_valued_set(X)
    | little_set(f19(X)) ) ).

cnf(single_valued_set3,axiom,
    ( single_valued_set(X)
    | little_set(f20(X)) ) ).

cnf(single_valued_set4,axiom,
    ( single_valued_set(X)
    | little_set(f21(X)) ) ).

cnf(single_valued_set5,axiom,
    ( single_valued_set(X)
    | member(ordered_pair(f19(X),f20(X)),X) ) ).

cnf(single_valued_set6,axiom,
    ( single_valued_set(X)
    | member(ordered_pair(f19(X),f21(X)),X) ) ).

cnf(single_valued_set7,axiom,
    ( single_valued_set(X)
    | f20(X) != f21(X) ) ).

%----Definition of function
cnf(function1,axiom,
    ( ~ function(Xf)
    | relation(Xf) ) ).

cnf(function2,axiom,
    ( ~ function(Xf)
    | single_valued_set(Xf) ) ).

cnf(function3,axiom,
    ( function(Xf)
    | ~ relation(Xf)
    | ~ single_valued_set(Xf) ) ).

%----Axiom C-4, image and substitution
cnf(image_and_substitution1,axiom,
    ( ~ member(Z,image(X,Xf))
    | ordered_pair_predicate(f22(Z,X,Xf)) ) ).

cnf(image_and_substitution2,axiom,
    ( ~ member(Z,image(X,Xf))
    | member(f22(Z,X,Xf),Xf) ) ).

cnf(image_and_substitution3,axiom,
    ( ~ member(Z,image(X,Xf))
    | member(first(f22(Z,X,Xf)),X) ) ).

cnf(image_and_substitution4,axiom,
    ( ~ member(Z,image(X,Xf))
    | second(f22(Z,X,Xf)) = Z ) ).

cnf(image_and_substitution5,axiom,
    ( member(Z,image(X,Xf))
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Y)
    | ~ member(Y,Xf)
    | ~ member(first(Y),X)
    | second(Y) != Z ) ).

cnf(image_and_substitution6,axiom,
    ( ~ little_set(X)
    | ~ function(Xf)
    | little_set(image(X,Xf)) ) ).

%----Definition of disjoint
cnf(disjoint1,axiom,
    ( ~ disjoint(X,Y)
    | ~ member(U,X)
    | ~ member(U,Y) ) ).

cnf(disjoint2,axiom,
    ( disjoint(X,Y)
    | member(f23(X,Y),X) ) ).

cnf(disjoint3,axiom,
    ( disjoint(X,Y)
    | member(f23(X,Y),Y) ) ).

%----Axiom D, regularity
cnf(regularity1,axiom,
    ( X = empty_set
    | member(f24(X),X) ) ).

cnf(regularity2,axiom,
    ( X = empty_set
    | disjoint(f24(X),X) ) ).

%----Axiom E, choice
cnf(choice1,axiom,
    function(f25) ).

cnf(choice2,axiom,
    ( ~ little_set(X)
    | X = empty_set
    | member(f26(X),X) ) ).

cnf(choice3,axiom,
    ( ~ little_set(X)
    | X = empty_set
    | member(ordered_pair(X,f26(X)),f25) ) ).

%----Definition of range_of
cnf(range_of1,axiom,
    ( ~ member(Z,range_of(X))
    | ordered_pair_predicate(f27(Z,X)) ) ).

cnf(range_of2,axiom,
    ( ~ member(Z,range_of(X))
    | member(f27(Z,X),X) ) ).

cnf(range_of3,axiom,
    ( ~ member(Z,range_of(X))
    | Z = second(f27(Z,X)) ) ).

cnf(range_of4,axiom,
    ( member(Z,range_of(X))
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Xp)
    | ~ member(Xp,X)
    | Z != second(Xp) ) ).

%----Definition of identity relation
cnf(identity_relation1,axiom,
    ( ~ member(Z,identity_relation)
    | ordered_pair_predicate(Z) ) ).

cnf(identity_relation2,axiom,
    ( ~ member(Z,identity_relation)
    | first(Z) = second(Z) ) ).

cnf(identity_relation3,axiom,
    ( member(Z,identity_relation)
    | ~ little_set(Z)
    | ~ ordered_pair_predicate(Z)
    | first(Z) != second(Z) ) ).

%----Definition of restrict
cnf(restrict,axiom,
    restrict(X,Y) = intersection(X,cross_product(Y,universal_set)) ).

%----Definition of one-to-one function
cnf(one_to_one_function1,axiom,
    ( ~ one_to_one_function(Xf)
    | function(Xf) ) ).

cnf(one_to_one_function2,axiom,
    ( ~ one_to_one_function(Xf)
    | function(converse(Xf)) ) ).

cnf(one_to_one_function3,axiom,
    ( one_to_one_function(Xf)
    | ~ function(Xf)
    | ~ function(converse(Xf)) ) ).

%----Definition of apply
cnf(apply1,axiom,
    ( ~ member(Z,apply(Xf,Y))
    | ordered_pair_predicate(f28(Z,Xf,Y)) ) ).

cnf(apply2,axiom,
    ( ~ member(Z,apply(Xf,Y))
    | member(f28(Z,Xf,Y),Xf) ) ).

cnf(apply3,axiom,
    ( ~ member(Z,apply(Xf,Y))
    | first(f28(Z,Xf,Y)) = Y ) ).

cnf(apply4,axiom,
    ( ~ member(Z,apply(Xf,Y))
    | member(Z,second(f28(Z,Xf,Y))) ) ).

cnf(apply5,axiom,
    ( member(Z,apply(Xf,Y))
    | ~ ordered_pair_predicate(W)
    | ~ member(W,Xf)
    | first(W) != Y
    | ~ member(Z,second(W)) ) ).

%----Definition of apply to 2 arguments
cnf(apply_to_two_arguments,axiom,
    apply_to_two_arguments(Xf,X,Y) = apply(Xf,ordered_pair(X,Y)) ).

%----Definition of maps
cnf(maps1,axiom,
    ( ~ maps(Xf,X,Y)
    | function(Xf) ) ).

cnf(maps2,axiom,
    ( ~ maps(Xf,X,Y)
    | domain_of(Xf) = X ) ).

cnf(maps3,axiom,
    ( ~ maps(Xf,X,Y)
    | subset(range_of(Xf),Y) ) ).

cnf(maps4,axiom,
    ( maps(Xf,X,Y)
    | ~ function(Xf)
    | domain_of(Xf) != X
    | ~ subset(range_of(Xf),Y) ) ).

%----Definition of closed
cnf(closed1,axiom,
    ( ~ closed(Xs,Xf)
    | little_set(Xs) ) ).

cnf(closed2,axiom,
    ( ~ closed(Xs,Xf)
    | little_set(Xf) ) ).

cnf(closed3,axiom,
    ( ~ closed(Xs,Xf)
    | maps(Xf,cross_product(Xs,Xs),Xs) ) ).

cnf(closed4,axiom,
    ( closed(Xs,Xf)
    | ~ little_set(Xs)
    | ~ little_set(Xf)
    | ~ maps(Xf,cross_product(Xs,Xs),Xs) ) ).

%----Definition of compose
cnf(compose1,axiom,
    ( ~ member(Z,compose(Xf,Xg))
    | little_set(f29(Z,Xf,Xg)) ) ).

cnf(compose2,axiom,
    ( ~ member(Z,compose(Xf,Xg))
    | little_set(f30(Z,Xf,Xg)) ) ).

cnf(compose3,axiom,
    ( ~ member(Z,compose(Xf,Xg))
    | little_set(f31(Z,Xf,Xg)) ) ).

cnf(compose4,axiom,
    ( ~ member(Z,compose(Xf,Xg))
    | Z = ordered_pair(f29(Z,Xf,Xg),f30(Z,Xf,Xg)) ) ).

cnf(compose5,axiom,
    ( ~ member(Z,compose(Xf,Xg))
    | member(ordered_pair(f29(Z,Xf,Xg),f31(Z,Xf,Xg)),Xf) ) ).

cnf(compose6,axiom,
    ( ~ member(Z,compose(Xf,Xg))
    | member(ordered_pair(f31(Z,Xf,Xg),f30(Z,Xf,Xg)),Xg) ) ).

cnf(compose7,axiom,
    ( member(Z,compose(Xf,Xg))
    | ~ little_set(Z)
    | ~ little_set(X)
    | ~ little_set(Y)
    | ~ little_set(W)
    | Z != ordered_pair(X,Y)
    | ~ member(ordered_pair(X,W),Xf)
    | ~ member(ordered_pair(W,Y),Xg) ) ).

%----Definition of a homomorphism
cnf(homomorphism1,axiom,
    ( ~ homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | closed(Xs1,Xf1) ) ).

cnf(homomorphism2,axiom,
    ( ~ homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | closed(Xs2,Xf2) ) ).

cnf(homomorphism3,axiom,
    ( ~ homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | maps(Xh,Xs1,Xs2) ) ).

cnf(homomorphism4,axiom,
    ( ~ homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | ~ member(X,Xs1)
    | ~ member(Y,Xs1)
    | apply(Xh,apply_to_two_arguments(Xf1,X,Y)) = apply_to_two_arguments(Xf2,apply(Xh,X),apply(Xh,Y)) ) ).

cnf(homomorphism5,axiom,
    ( homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | ~ closed(Xs1,Xf1)
    | ~ closed(Xs2,Xf2)
    | ~ maps(Xh,Xs1,Xs2)
    | member(f32(Xh,Xs1,Xf1,Xs2,Xf2),Xs1) ) ).

cnf(homomorphism6,axiom,
    ( homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | ~ closed(Xs1,Xf1)
    | ~ closed(Xs2,Xf2)
    | ~ maps(Xh,Xs1,Xs2)
    | member(f33(Xh,Xs1,Xf1,Xs2,Xf2),Xs1) ) ).

cnf(homomorphism7,axiom,
    ( homomorphism(Xh,Xs1,Xf1,Xs2,Xf2)
    | ~ closed(Xs1,Xf1)
    | ~ closed(Xs2,Xf2)
    | ~ maps(Xh,Xs1,Xs2)
    | apply(Xh,apply_to_two_arguments(Xf1,f32(Xh,Xs1,Xf1,Xs2,Xf2),f33(Xh,Xs1,Xf1,Xs2,Xf2))) != apply_to_two_arguments(Xf2,apply(Xh,f32(Xh,Xs1,Xf1,Xs2,Xf2)),apply(Xh,f33(Xh,Xs1,Xf1,Xs2,Xf2))) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET004-0 : TPTP v9.0.0. Bugfixed v2.1.0.
% Domain   : Set Theory
% Axioms   : Set theory axioms based on NBG set theory
% Version  : [Qua92] axioms.
% English  :

% Refs     : [Qua92] Quaife (1992), Automated Deduction in von Neumann-Bern
% Source   : [Qua92]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of clauses     :   91 (  29 unt;   8 nHn;  62 RR)
%            Number of literals    :  181 (  39 equ;  84 neg)
%            Maximal clause size   :    5 (   1 avg)
%            Maximal term depth    :    6 (   1 avg)
%            Number of predicates  :   10 (   9 usr;   0 prp; 1-3 aty)
%            Number of functors    :   38 (  38 usr;   8 con; 0-3 aty)
%            Number of variables   :  176 (  25 sgn)
% SPC      : 

% Comments :
% Bugfixes : v2.1.0 - Clause compatible4 fixed
%--------------------------------------------------------------------------
%----GROUP 1:          AXIOMS AND BASIC DEFINITIONS.

%----Axiom A-1:  sets are classes (omitted because all objects are
%----classes).

%----Definition of < (subclass).
%----a:x:a:y:((x < y) <=> a:u:((u e x) ==> (u e y))).
cnf(subclass_members,axiom,
    ( ~ subclass(X,Y)
    | ~ member(U,X)
    | member(U,Y) ) ).

cnf(not_subclass_members1,axiom,
    ( member(not_subclass_element(X,Y),X)
    | subclass(X,Y) ) ).

cnf(not_subclass_members2,axiom,
    ( ~ member(not_subclass_element(X,Y),Y)
    | subclass(X,Y) ) ).

%----Axiom A-2: elements of classes are sets.
%----a:x:(x < universal_class).
%----Singleton variables OK.
cnf(class_elements_are_sets,axiom,
    subclass(X,universal_class) ).

%----Axiom A-3: principle of extensionality.
%----a:x:a:y:((x = y) <=> (x < y) & (y < x)).
cnf(equal_implies_subclass1,axiom,
    ( X != Y
    | subclass(X,Y) ) ).

cnf(equal_implies_subclass2,axiom,
    ( X != Y
    | subclass(Y,X) ) ).

cnf(subclass_implies_equal,axiom,
    ( ~ subclass(X,Y)
    | ~ subclass(Y,X)
    | X = Y ) ).

%----Axiom A-4: existence of unordered pair.
%----a:u:a:x:a:y:((u e {x, y}) <=> (u e universal_class)
%----& (u = x | u = y)).
%----a:x:a:y:({x, y} e universal_class).
cnf(unordered_pair_member,axiom,
    ( ~ member(U,unordered_pair(X,Y))
    | U = X
    | U = Y ) ).

%----(x e universal_class), (u = x) --> (u e {x, y}).
%----Singleton variables OK.
cnf(unordered_pair2,axiom,
    ( ~ member(X,universal_class)
    | member(X,unordered_pair(X,Y)) ) ).

%----(y e universal_class), (u = y) --> (u e {x, y}).
%----Singleton variables OK.
cnf(unordered_pair3,axiom,
    ( ~ member(Y,universal_class)
    | member(Y,unordered_pair(X,Y)) ) ).

%----Singleton variables OK.
cnf(unordered_pairs_in_universal,axiom,
    member(unordered_pair(X,Y),universal_class) ).

%----Definition of singleton set.
%----a:x:({x} = {x, x}).
cnf(singleton_set,axiom,
    unordered_pair(X,X) = singleton(X) ).

%----See Theorem (SS6) for memb.

%----Definition of ordered pair.
%----a:x:a:y:([x,y] = {{x}, {x, {y}}}).
cnf(ordered_pair,axiom,
    unordered_pair(singleton(X),unordered_pair(X,singleton(Y))) = ordered_pair(X,Y) ).

%----Axiom B-5'a: Cartesian product.
%----a:u:a:v:a:y:(([u,v] e cross_product(x,y)) <=> (u e x) & (v e y)).
%----Singleton variables OK.
cnf(cartesian_product1,axiom,
    ( ~ member(ordered_pair(U,V),cross_product(X,Y))
    | member(U,X) ) ).

%----Singleton variables OK.
cnf(cartesian_product2,axiom,
    ( ~ member(ordered_pair(U,V),cross_product(X,Y))
    | member(V,Y) ) ).

cnf(cartesian_product3,axiom,
    ( ~ member(U,X)
    | ~ member(V,Y)
    | member(ordered_pair(U,V),cross_product(X,Y)) ) ).

%----See Theorem (OP6) for 1st and 2nd.

%----Axiom B-5'b: Cartesian product.
%----a:z:(z e cross_product(x,y) --> ([first(z),second(z)] = z)
%----Singleton variables OK.
cnf(cartesian_product4,axiom,
    ( ~ member(Z,cross_product(X,Y))
    | ordered_pair(first(Z),second(Z)) = Z ) ).

%----Axiom B-1: E (element relation).
%----(E < cross_product(universal_class,universal_class)).
%----a:x:a:y:(([x,y] e E) <=> ([x,y] e cross_product(universal_class,
%----universal_class)) (x e y)).
cnf(element_relation1,axiom,
    subclass(element_relation,cross_product(universal_class,universal_class)) ).

cnf(element_relation2,axiom,
    ( ~ member(ordered_pair(X,Y),element_relation)
    | member(X,Y) ) ).

cnf(element_relation3,axiom,
    ( ~ member(ordered_pair(X,Y),cross_product(universal_class,universal_class))
    | ~ member(X,Y)
    | member(ordered_pair(X,Y),element_relation) ) ).

%----Axiom B-2: * (intersection).
%----a:z:a:x:a:y:((z e (x * y)) <=> (z e x) & (z e y)).
%----Singleton variables OK.
cnf(intersection1,axiom,
    ( ~ member(Z,intersection(X,Y))
    | member(Z,X) ) ).

%----Singleton variables OK.
cnf(intersection2,axiom,
    ( ~ member(Z,intersection(X,Y))
    | member(Z,Y) ) ).

cnf(intersection3,axiom,
    ( ~ member(Z,X)
    | ~ member(Z,Y)
    | member(Z,intersection(X,Y)) ) ).

%----Axiom B-3: complement.
%----a:z:a:x:((z e ~(x)) <=> (z e universal_class) & -(z e x)).
cnf(complement1,axiom,
    ( ~ member(Z,complement(X))
    | ~ member(Z,X) ) ).

cnf(complement2,axiom,
    ( ~ member(Z,universal_class)
    | member(Z,complement(X))
    | member(Z,X) ) ).

%---- Theorem (SP2) introduces the null class O.

%----Definition of + (union).
%----a:x:a:y:((x + y) = ~((~(x) * ~(y)))).
cnf(union,axiom,
    complement(intersection(complement(X),complement(Y))) = union(X,Y) ).

%----Definition of & (exclusive or). (= symmetric difference).
%----a:x:a:y:((x y) = (~(x * y) * ~(~(x) * ~(y)))).
cnf(symmetric_difference,axiom,
    intersection(complement(intersection(X,Y)),complement(intersection(complement(X),complement(Y)))) = symmetric_difference(X,Y) ).

%----Definition of restriction.
%----a:x(restrict(xr,x,y) = (xr * cross_product(x,y))).
%----This is extra to the paper
cnf(restriction1,axiom,
    intersection(Xr,cross_product(X,Y)) = restrict(Xr,X,Y) ).

cnf(restriction2,axiom,
    intersection(cross_product(X,Y),Xr) = restrict(Xr,X,Y) ).

%----Axiom B-4: D (domain_of).
%----a:y:a:z:((z e domain_of(x)) <=> (z e universal_class) &
%---- -(restrict(x,{z},universal_class) = O)).
%----next is subsumed by A-2.
%------> (domain_of(x) < universal_class).
cnf(domain1,axiom,
    ( restrict(X,singleton(Z),universal_class) != null_class
    | ~ member(Z,domain_of(X)) ) ).

cnf(domain2,axiom,
    ( ~ member(Z,universal_class)
    | restrict(X,singleton(Z),universal_class) = null_class
    | member(Z,domain_of(X)) ) ).

%----Axiom B-7: rotate.
%----a:x:(rotate(x) <  cross_product(cross_product(universal_class,
%----universal_class),universal_class)).
%----a:x:a:u:a:v:a:w:(([[u,v],w] e rotate(x)) <=> ([[u,v],w]]
%---- e cross_product(cross_product(universal_class,universal_class),
%----universal_class)) & ([[v,w],u]] e x).
%----Singleton variables OK.
cnf(rotate1,axiom,
    subclass(rotate(X),cross_product(cross_product(universal_class,universal_class),universal_class)) ).

cnf(rotate2,axiom,
    ( ~ member(ordered_pair(ordered_pair(U,V),W),rotate(X))
    | member(ordered_pair(ordered_pair(V,W),U),X) ) ).

cnf(rotate3,axiom,
    ( ~ member(ordered_pair(ordered_pair(V,W),U),X)
    | ~ member(ordered_pair(ordered_pair(U,V),W),cross_product(cross_product(universal_class,universal_class),universal_class))
    | member(ordered_pair(ordered_pair(U,V),W),rotate(X)) ) ).

%----Axiom B-8: flip.
%----a:x:(flip(x) <  cross_product(cross_product(universal_class,
%----universal_class),universal_class)).
%----a:z:a:u:a:v:a:w:(([[u,v],w] e flip(x)) <=> ([[u,v],w]
%----e cross_product(cross_product(universal_class,universal_class),
%----universal_class)) & ([[v,u],w] e x).
%----Singleton variables OK.
cnf(flip1,axiom,
    subclass(flip(X),cross_product(cross_product(universal_class,universal_class),universal_class)) ).

cnf(flip2,axiom,
    ( ~ member(ordered_pair(ordered_pair(U,V),W),flip(X))
    | member(ordered_pair(ordered_pair(V,U),W),X) ) ).

cnf(flip3,axiom,
    ( ~ member(ordered_pair(ordered_pair(V,U),W),X)
    | ~ member(ordered_pair(ordered_pair(U,V),W),cross_product(cross_product(universal_class,universal_class),universal_class))
    | member(ordered_pair(ordered_pair(U,V),W),flip(X)) ) ).

%----Definition of inverse.
%----a:y:(inverse(y) = domain_of(flip(cross_product(y,V)))).
cnf(inverse,axiom,
    domain_of(flip(cross_product(Y,universal_class))) = inverse(Y) ).

%----Definition of R (range_of).
%----a:z:(range_of(z) = domain_of(inverse(z))).
cnf(range_of,axiom,
    domain_of(inverse(Z)) = range_of(Z) ).

%----Definition of domain.
%----a:z:a:x:a:y:(domain(z,x,y) = first(notsub(restrict(z,x,{y}),O))).
cnf(domain,axiom,
    first(not_subclass_element(restrict(Z,X,singleton(Y)),null_class)) = domain(Z,X,Y) ).

%----Definition of range.
%----a:z:a:x:(range(z,x,y) = second(notsub(restrict(z,{x},y),O))).
cnf(range,axiom,
    second(not_subclass_element(restrict(Z,singleton(X),Y),null_class)) = range(Z,X,Y) ).

%----Definition of image.
%----a:x:a:xr:((xr image x) = range_of(restrict(xr,x,V))).
cnf(image,axiom,
    range_of(restrict(Xr,X,universal_class)) = image(Xr,X) ).

%----Definition of successor.
%----a:x:(successor(x) = (x + {x})).
cnf(successor,axiom,
    union(X,singleton(X)) = successor(X) ).

%----Explicit definition of successor_relation.
%------> ((cross_product(V,V) * ~(((E ^ ~(inverse((E + I)))) +
%----(~(E) ^ inverse((E + I)))))) = successor_relation).
%----Definition of successor_relation from the Class Existence Theorem.
%----a:x:a:y:([x,y] e successor_relation <=> x e V & successor(x) = y).
%----The above FOF does not agree with the book
cnf(successor_relation1,axiom,
    subclass(successor_relation,cross_product(universal_class,universal_class)) ).

cnf(successor_relation2,axiom,
    ( ~ member(ordered_pair(X,Y),successor_relation)
    | successor(X) = Y ) ).

%----This is what's in the book and paper. Does not change axiom.
% input_clause(successor_relation3,axiom,
%     [--equal(successor(X),Y),
%      --member(X,universal_class),
%      ++member(ordered_pair(X,Y),successor_relation)]).

%----This is what I got by email from Quaife
cnf(successor_relation3,axiom,
    ( successor(X) != Y
    | ~ member(ordered_pair(X,Y),cross_product(universal_class,universal_class))
    | member(ordered_pair(X,Y),successor_relation) ) ).

%----Definition of inductive a:x:(inductive(x) <=> null_class
%----e x & (successor_relation image x) < x)).
cnf(inductive1,axiom,
    ( ~ inductive(X)
    | member(null_class,X) ) ).

cnf(inductive2,axiom,
    ( ~ inductive(X)
    | subclass(image(successor_relation,X),X) ) ).

cnf(inductive3,axiom,
    ( ~ member(null_class,X)
    | ~ subclass(image(successor_relation,X),X)
    | inductive(X) ) ).

%----Axiom C-1: infinity.
%----e:x:((x e V) & inductive(x) & a:y:(inductive(y) ==> (x < y))).
%----e:x:((x e V) & (O e x) & ((successor_relation image x) < x)
%----        & a:y:((O e y) & ((successor_relation image y) < y) ==>
%----(x < y))).
cnf(omega_is_inductive1,axiom,
    inductive(omega) ).

cnf(omega_is_inductive2,axiom,
    ( ~ inductive(Y)
    | subclass(omega,Y) ) ).

cnf(omega_in_universal,axiom,
    member(omega,universal_class) ).

%----These were commented out in the set Quaife sent me, and are not
%----in the paper true --> (null_class e omega).
%----true --> ((successor_relation image omega) < omega).
%----(null_class e y), ((successor_relation image y) < y) -->
%----(omega < y). true --> (omega e universal_class).

%----Definition of U (sum class).
%----a:x:(sum_class(x) = domain_of(restrict(E,V,x))).
cnf(sum_class_definition,axiom,
    domain_of(restrict(element_relation,universal_class,X)) = sum_class(X) ).

%----Axiom C-2: U (sum class).
%----a:x:((x e V) ==> (sum_class(x) e V)).
cnf(sum_class2,axiom,
    ( ~ member(X,universal_class)
    | member(sum_class(X),universal_class) ) ).

%----Definition of P (power class).
%----a:x:(power_class(x) = ~((E image ~(x)))).
cnf(power_class_definition,axiom,
    complement(image(element_relation,complement(X))) = power_class(X) ).

%----Axiom C-3: P (power class).
%----a:u:((u e V) ==> (power_class(u) e V)).
cnf(power_class2,axiom,
    ( ~ member(U,universal_class)
    | member(power_class(U),universal_class) ) ).

%----Definition of compose.
%----a:xr:a:yr:((yr ^ xr) < cross_product(V,V)).
%----a:u:a:v:a:xr:a:yr:(([u,v] e (yr ^ xr)) <=> ([u,v]
%----e cross_product(V,V)) & (v e (yr image (xr image {u})))).
%----Singleton variables OK.
cnf(compose1,axiom,
    subclass(compose(Yr,Xr),cross_product(universal_class,universal_class)) ).

cnf(compose2,axiom,
    ( ~ member(ordered_pair(Y,Z),compose(Yr,Xr))
    | member(Z,image(Yr,image(Xr,singleton(Y)))) ) ).

cnf(compose3,axiom,
    ( ~ member(Z,image(Yr,image(Xr,singleton(Y))))
    | ~ member(ordered_pair(Y,Z),cross_product(universal_class,universal_class))
    | member(ordered_pair(Y,Z),compose(Yr,Xr)) ) ).

%----7/21/90 eliminate SINGVAL and just use FUNCTION.
%----Not eliminated in TPTP - I'm following the paper
cnf(single_valued_class1,axiom,
    ( ~ single_valued_class(X)
    | subclass(compose(X,inverse(X)),identity_relation) ) ).

cnf(single_valued_class2,axiom,
    ( ~ subclass(compose(X,inverse(X)),identity_relation)
    | single_valued_class(X) ) ).

%----Definition of function.
%----a:xf:(function(xf) <=> (xf < cross_product(V,V)) & ((xf
%----^ inverse(xf)) < identity_relation)).
cnf(function1,axiom,
    ( ~ function(Xf)
    | subclass(Xf,cross_product(universal_class,universal_class)) ) ).

cnf(function2,axiom,
    ( ~ function(Xf)
    | subclass(compose(Xf,inverse(Xf)),identity_relation) ) ).

cnf(function3,axiom,
    ( ~ subclass(Xf,cross_product(universal_class,universal_class))
    | ~ subclass(compose(Xf,inverse(Xf)),identity_relation)
    | function(Xf) ) ).

%----Axiom C-4: replacement.
%----a:x:((x e V) & function(xf) ==> ((xf image x) e V)).
cnf(replacement,axiom,
    ( ~ function(Xf)
    | ~ member(X,universal_class)
    | member(image(Xf,X),universal_class) ) ).

%----Axiom D: regularity.
%----a:x:(-(x = O) ==> e:u:((u e V) & (u e x) & ((u * x) = O))).
cnf(regularity1,axiom,
    ( X = null_class
    | member(regular(X),X) ) ).

cnf(regularity2,axiom,
    ( X = null_class
    | intersection(X,regular(X)) = null_class ) ).

%----Definition of apply (apply).
%----a:xf:a:y:((xf apply y) = sum_class((xf image {y}))).
cnf(apply,axiom,
    sum_class(image(Xf,singleton(Y))) = apply(Xf,Y) ).

%----Axiom E: universal choice.
%----e:xf:(function(xf) & a:y:((y e V) ==> (y = null_class) |
%----((xf apply y) e y))).
cnf(choice1,axiom,
    function(choice) ).

cnf(choice2,axiom,
    ( ~ member(Y,universal_class)
    | Y = null_class
    | member(apply(choice,Y),Y) ) ).

%----GROUP 2:             MORE SET THEORY DEFINITIONS.

%----Definition of one_to_one (one-to-one function).
%----a:xf:(one_to_one(xf) <=> function(xf) & function(inverse(xf))).
cnf(one_to_one1,axiom,
    ( ~ one_to_one(Xf)
    | function(Xf) ) ).

cnf(one_to_one2,axiom,
    ( ~ one_to_one(Xf)
    | function(inverse(Xf)) ) ).

cnf(one_to_one3,axiom,
    ( ~ function(inverse(Xf))
    | ~ function(Xf)
    | one_to_one(Xf) ) ).

%----Definition of S (subset relation).
cnf(subset_relation,axiom,
    intersection(cross_product(universal_class,universal_class),intersection(cross_product(universal_class,universal_class),complement(compose(complement(element_relation),inverse(element_relation))))) = subset_relation ).

%----Definition of I (identity relation).
cnf(identity_relation,axiom,
    intersection(inverse(subset_relation),subset_relation) = identity_relation ).

%----Definition of diagonalization.
%----a:xr:(diagonalise(xr) = ~(domain_of((identity_relation * xr)))).
cnf(diagonalisation,axiom,
    complement(domain_of(intersection(Xr,identity_relation))) = diagonalise(Xr) ).

%----Definition of Cantor class.
cnf(cantor_class,axiom,
    intersection(domain_of(X),diagonalise(compose(inverse(element_relation),X))) = cantor(X) ).

%----Definition of operation.
%----a:xf:(operation(xf) <=> function(xf) & (cross_product(domain_of(
%----domain_of(xf)),domain_of(domain_of(xf))) = domain_of(xf))
%----& (range_of(xf) < domain_of(domain_of(xf))).
cnf(operation1,axiom,
    ( ~ operation(Xf)
    | function(Xf) ) ).

cnf(operation2,axiom,
    ( ~ operation(Xf)
    | cross_product(domain_of(domain_of(Xf)),domain_of(domain_of(Xf))) = domain_of(Xf) ) ).

cnf(operation3,axiom,
    ( ~ operation(Xf)
    | subclass(range_of(Xf),domain_of(domain_of(Xf))) ) ).

cnf(operation4,axiom,
    ( ~ function(Xf)
    | cross_product(domain_of(domain_of(Xf)),domain_of(domain_of(Xf))) != domain_of(Xf)
    | ~ subclass(range_of(Xf),domain_of(domain_of(Xf)))
    | operation(Xf) ) ).

%----Definition of compatible.
%----a:xh:a:xf1:a:af2: (compatible(xh,xf1,xf2) <=> function(xh)
%----& (domain_of(domain_of(xf1)) = domain_of(xh)) & (range_of(xh)
%----< domain_of(domain_of(xf2)))).
%----Singleton variables OK.
cnf(compatible1,axiom,
    ( ~ compatible(Xh,Xf1,Xf2)
    | function(Xh) ) ).

%----Singleton variables OK.
cnf(compatible2,axiom,
    ( ~ compatible(Xh,Xf1,Xf2)
    | domain_of(domain_of(Xf1)) = domain_of(Xh) ) ).

%----Singleton variables OK.
cnf(compatible3,axiom,
    ( ~ compatible(Xh,Xf1,Xf2)
    | subclass(range_of(Xh),domain_of(domain_of(Xf2))) ) ).

cnf(compatible4,axiom,
    ( ~ function(Xh)
    | domain_of(domain_of(Xf1)) != domain_of(Xh)
    | ~ subclass(range_of(Xh),domain_of(domain_of(Xf2)))
    | compatible(Xh,Xf1,Xf2) ) ).

%----Definition of homomorphism.
%----a:xh:a:xf1:a:xf2: (homomorphism(xh,xf1,xf2) <=>
%---- operation(xf1) & operation(xf2) & compatible(xh,xf1,xf2) &
%---- a:x:a:y:(([x,y] e domain_of(xf1)) ==> (((xf2 apply [(xh apply x),
%----(xh apply y)]) = (xh apply (xf1 apply [x,y])))).
%----Singleton variables OK.
cnf(homomorphism1,axiom,
    ( ~ homomorphism(Xh,Xf1,Xf2)
    | operation(Xf1) ) ).

%----Singleton variables OK.
cnf(homomorphism2,axiom,
    ( ~ homomorphism(Xh,Xf1,Xf2)
    | operation(Xf2) ) ).

cnf(homomorphism3,axiom,
    ( ~ homomorphism(Xh,Xf1,Xf2)
    | compatible(Xh,Xf1,Xf2) ) ).

cnf(homomorphism4,axiom,
    ( ~ homomorphism(Xh,Xf1,Xf2)
    | ~ member(ordered_pair(X,Y),domain_of(Xf1))
    | apply(Xf2,ordered_pair(apply(Xh,X),apply(Xh,Y))) = apply(Xh,apply(Xf1,ordered_pair(X,Y))) ) ).

cnf(homomorphism5,axiom,
    ( ~ operation(Xf1)
    | ~ operation(Xf2)
    | ~ compatible(Xh,Xf1,Xf2)
    | member(ordered_pair(not_homomorphism1(Xh,Xf1,Xf2),not_homomorphism2(Xh,Xf1,Xf2)),domain_of(Xf1))
    | homomorphism(Xh,Xf1,Xf2) ) ).

cnf(homomorphism6,axiom,
    ( ~ operation(Xf1)
    | ~ operation(Xf2)
    | ~ compatible(Xh,Xf1,Xf2)
    | apply(Xf2,ordered_pair(apply(Xh,not_homomorphism1(Xh,Xf1,Xf2)),apply(Xh,not_homomorphism2(Xh,Xf1,Xf2)))) != apply(Xh,apply(Xf1,ordered_pair(not_homomorphism1(Xh,Xf1,Xf2),not_homomorphism2(Xh,Xf1,Xf2))))
    | homomorphism(Xh,Xf1,Xf2) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET004-1 : TPTP v9.0.0. Bugfixed v1.0.1.
% Domain   : Set Theory (Boolean Algebra definitions)
% Axioms   : Set theory (Boolean algebra) axioms based on NBG set theory
% Version  : [Qua92a] axioms.
% English  :

% Refs     : [Qua92a] Quaife (1992), Automated Deduction in von Neumann-Bern
%          : [Qua92b] Quaife (1992), Email to G. Sutcliffe
% Source   : [Qua92b]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of clauses     :   21 (   8 unt;   0 nHn;  17 RR)
%            Number of literals    :   37 (  10 equ;  16 neg)
%            Maximal clause size   :    3 (   1 avg)
%            Maximal term depth    :    5 (   2 avg)
%            Number of predicates  :    5 (   4 usr;   0 prp; 1-3 aty)
%            Number of functors    :   26 (  26 usr;   7 con; 0-3 aty)
%            Number of variables   :   38 (   7 sgn)
% SPC      : 

% Comments : Requires SET004-0.ax
%          : Not all of these definitions appear in [Qua92a]. Some were
%            extracted from [Qua92b]
% Bugfixes : v1.0.1 - Duplicate axioms single_valued_term_defn? removed.
%--------------------------------------------------------------------------
%----(CO25DEF): Definition of compose_class(x) term, where x may
%----be a class. Not in [Quaife, 1992].
cnf(compose_class_definition1,axiom,
    subclass(compose_class(X),cross_product(universal_class,universal_class)) ).

cnf(compose_class_definition2,axiom,
    ( ~ member(ordered_pair(Y,Z),compose_class(X))
    | compose(X,Y) = Z ) ).

cnf(compose_class_definition3,axiom,
    ( ~ member(ordered_pair(Y,Z),cross_product(universal_class,universal_class))
    | compose(X,Y) != Z
    | member(ordered_pair(Y,Z),compose_class(X)) ) ).

%----(CO20DEF): Definition of composition_function. Not in [Quaife,
%----1992].
cnf(definition_of_composition_function1,axiom,
    subclass(composition_function,cross_product(universal_class,cross_product(universal_class,universal_class))) ).

cnf(definition_of_composition_function2,axiom,
    ( ~ member(ordered_pair(X,ordered_pair(Y,Z)),composition_function)
    | compose(X,Y) = Z ) ).

cnf(definition_of_composition_function3,axiom,
    ( ~ member(ordered_pair(X,Y),cross_product(universal_class,universal_class))
    | member(ordered_pair(X,ordered_pair(Y,compose(X,Y))),composition_function) ) ).

%----(DODEF11): Definition of domain_relation by the class existence
%----theorem. Not in [Quaife, 19992].
cnf(definition_of_domain_relation1,axiom,
    subclass(domain_relation,cross_product(universal_class,universal_class)) ).

cnf(definition_of_domain_relation2,axiom,
    ( ~ member(ordered_pair(X,Y),domain_relation)
    | domain_of(X) = Y ) ).

cnf(definition_of_domain_relation3,axiom,
    ( ~ member(X,universal_class)
    | member(ordered_pair(X,domain_of(X)),domain_relation) ) ).

%----(SV2DEF) Definitions of terms for (SV3) Called FU2DEF in Quaife's
%----email
cnf(single_valued_term_defn1,axiom,
    first(not_subclass_element(compose(X,inverse(X)),identity_relation)) = single_valued1(X) ).

cnf(single_valued_term_defn2,axiom,
    second(not_subclass_element(compose(X,inverse(X)),identity_relation)) = single_valued2(X) ).

cnf(single_valued_term_defn3,axiom,
    domain(X,image(inverse(X),singleton(single_valued1(X))),single_valued2(X)) = single_valued3(X) ).

%----(CO14DEF): Definition of singleton relation.
cnf(compose_can_define_singleton,axiom,
    intersection(complement(compose(element_relation,complement(identity_relation))),element_relation) = singleton_relation ).

%----(AP15): definition of application function. Not in [Qua92]
cnf(application_function_defn1,axiom,
    subclass(application_function,cross_product(universal_class,cross_product(universal_class,universal_class))) ).

cnf(application_function_defn2,axiom,
    ( ~ member(ordered_pair(X,ordered_pair(Y,Z)),application_function)
    | member(Y,domain_of(X)) ) ).

cnf(application_function_defn3,axiom,
    ( ~ member(ordered_pair(X,ordered_pair(Y,Z)),application_function)
    | apply(X,Y) = Z ) ).

cnf(application_function_defn4,axiom,
    ( ~ member(ordered_pair(X,ordered_pair(Y,Z)),cross_product(universal_class,cross_product(universal_class,universal_class)))
    | ~ member(Y,domain_of(X))
    | member(ordered_pair(X,ordered_pair(Y,apply(X,Y))),application_function) ) ).

%----Definition of maps. Not in [Qua92].
%----a:xf:a:x:a:y:(maps(xf,x,y) <=> function(xf) & domain(xf)
%----= x & range(xf) < y).
cnf(maps1,axiom,
    ( ~ maps(Xf,X,Y)
    | function(Xf) ) ).

cnf(maps2,axiom,
    ( ~ maps(Xf,X,Y)
    | domain_of(Xf) = X ) ).

cnf(maps3,axiom,
    ( ~ maps(Xf,X,Y)
    | subclass(range_of(Xf),Y) ) ).

cnf(maps4,axiom,
    ( ~ function(Xf)
    | ~ subclass(range_of(Xf),Y)
    | maps(Xf,domain_of(Xf),Y) ) ).

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET005+0 : TPTP v9.0.0. Bugfixed v5.4.0.
% Domain   : Set Theory
% Axioms   : Set theory axioms based on NBG set theory
% Version  : [Quaife, 1992] axioms : Reduced & Augmented > Complete.
% English  :

% Refs     : [Qua92] Quaife (1992), Automated Deduction in von Neumann-Bern
%          : [BL+86] Boyer et al. (1986), Set Theory in First-Order Logic:
% Source   : [Qua92]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of formulae    :   43 (  16 unt;   0 def)
%            Number of atoms       :  100 (  19 equ)
%            Maximal formula atoms :    4 (   2 avg)
%            Number of connectives :   62 (   5   ~;   3   |;  26   &)
%                                         (  19 <=>;   9  =>;   0  <=;   0 <~>)
%            Maximal formula depth :    7 (   4 avg)
%            Maximal term depth    :    4 (   1 avg)
%            Number of predicates  :    6 (   5 usr;   0 prp; 1-2 aty)
%            Number of functors    :   26 (  26 usr;   5 con; 0-3 aty)
%            Number of variables   :   86 (  81   !;   5   ?)
% SPC      : 

% Comments :
% Bugfixes : v5.4.0 - Fixed compose_defn2, added first_second, added
%            identity_relation.
%--------------------------------------------------------------------------
%----Axiom A-1: Sets are classes (omitted because all objects are
%----classes).
% input_formula(sets_are_classes,axiom,
%     ! [X] :
%       (m(X) => cls(X))).

%----Definition of subclass. By doing this early, following axioms are
%----simplified. See A-2 for a clear example. This is what Mendelson does.
fof(subclass_defn,axiom,
    ! [X,Y] :
      ( subclass(X,Y)
    <=> ! [U] :
          ( member(U,X)
         => member(U,Y) ) ) ).

%----Axiom A-2: Elements of classes are sets.
fof(class_elements_are_sets,axiom,
    ! [X] : subclass(X,universal_class) ).

%----Axiom A-3: Principle of extensionality. Quaife notes that this is
%----different from the Boyer version. It is the Mendelson version.
fof(extensionality,axiom,
    ! [X,Y] :
      ( X = Y
    <=> ( subclass(X,Y)
        & subclass(Y,X) ) ) ).

%----Axiom A-4: Existence of unordered pair
fof(unordered_pair_defn,axiom,
    ! [U,X,Y] :
      ( member(U,unordered_pair(X,Y))
    <=> ( member(U,universal_class)
        & ( U = X
          | U = Y ) ) ) ).

%----Quaife says "if I were to do it again I'd use ..."
%----McCune recommends not doing this, so I havn't
% input_formula(unordered_pair1,axiom,(
%     ! [U,X,Y] :
%       ( member(U,unordered_pair(X,Y))
%     <=> ( member(U,universal_class)
%         & ( equal(U,X)
%           | member(U,Y) ) ) )    )).

fof(unordered_pair,axiom,
    ! [X,Y] : member(unordered_pair(X,Y),universal_class) ).

%----Definition of singleton set, needed for ordered pair.
fof(singleton_set_defn,axiom,
    ! [X] : singleton(X) = unordered_pair(X,X) ).

%----Definition of ordered pair, needed for B-5
fof(ordered_pair_defn,axiom,
    ! [X,Y] : ordered_pair(X,Y) = unordered_pair(singleton(X),unordered_pair(X,singleton(Y))) ).

%----This is different from Goedel where it is
% input_formula(ordered_pair,axiom,(
%     ! [X,Y] : equal(ordered_pair(X,Y),unordered_pair(singleton(X),
% unordered_pair(X,Y)))   )).
%----This is motivated in Quaife's book p. 30 Section 3.5.

%----Axiom B-5: Cartesian product (not explicitly defined in Goedel)
%----Brought forward so cross_product can be used in B-1
%----In this and some other axioms, Goedel's axioms use existential
%----quantification rather than explicit definition.
fof(cross_product_defn,axiom,
    ! [U,V,X,Y] :
      ( member(ordered_pair(U,V),cross_product(X,Y))
    <=> ( member(U,X)
        & member(V,Y) ) ) ).

%----Added axiom to define first and second, which are introduced as Skolem
%----functions in the CNF versions of theorem OP6.
fof(first_second,axiom,
    ! [X,Y] :
      ( ( member(X,universal_class)
        & member(Y,universal_class) )
     => ( first(ordered_pair(X,Y)) = X
        & second(ordered_pair(X,Y)) = Y ) ) ).

fof(cross_product,axiom,
    ! [X,Y,Z] :
      ( member(Z,cross_product(X,Y))
     => Z = ordered_pair(first(Z),second(Z)) ) ).

%----Axiom B-1: Element relation (not explicitly defined in Goedel)
%----This is an example of undoing a simplification made by Quaife for
%----CNF systems (see book p. 28, Section 3.4).
fof(element_relation_defn,axiom,
    ! [X,Y] :
      ( member(ordered_pair(X,Y),element_relation)
    <=> ( member(Y,universal_class)
        & member(X,Y) ) ) ).

%----Quaife's version included member(X,universal_class) in the RHS of the
%----<=>, but that's not required as member(X,Y) => member(X,universal_class)
%----The equiavlence of the two forms has been proved.

fof(element_relation,axiom,
    subclass(element_relation,cross_product(universal_class,universal_class)) ).

%----Axiom B-2: Intersection (not explicitly defined in Goedel)
fof(intersection,axiom,
    ! [X,Y,Z] :
      ( member(Z,intersection(X,Y))
    <=> ( member(Z,X)
        & member(Z,Y) ) ) ).

%----Axiom B-3: Complement (not explicitly defined in Goedel)
fof(complement,axiom,
    ! [X,Z] :
      ( member(Z,complement(X))
    <=> ( member(Z,universal_class)
        & ~ member(Z,X) ) ) ).

%----Quaife has the definitions for union and symmetric difference in here
%----(about). I have moved union to later where it is needed. Symmetric
%----difference is not needed for Goedel's axioms, so I have moved it to
%----SET005+1.ax

%----Definition of restrict. Needed for B-4 domain_of
fof(restrict_defn,axiom,
    ! [X,XR,Y] : restrict(XR,X,Y) = intersection(XR,cross_product(X,Y)) ).

%----Definition of null_class. Needed for B-4 domain_of
%----This is dependent, but Plaisted says it's unreasonable to omit it.
fof(null_class_defn,axiom,
    ! [X] : ~ member(X,null_class) ).

%----Axiom B-4: Domain of (not explicitly defined in Goedel)
fof(domain_of,axiom,
    ! [X,Z] :
      ( member(Z,domain_of(X))
    <=> ( member(Z,universal_class)
        & restrict(X,singleton(Z),universal_class) != null_class ) ) ).

%----Axiom B-5 is earlier as it defines cross_product, used in B-1
%----Axiom B-6 is proved as a theorem

%----Axiom B-7: Existence of rotate (not explicitly defined in Goedel)
fof(rotate_defn,axiom,
    ! [X,U,V,W] :
      ( member(ordered_pair(ordered_pair(U,V),W),rotate(X))
    <=> ( member(ordered_pair(ordered_pair(U,V),W),cross_product(cross_product(universal_class,universal_class),universal_class))
        & member(ordered_pair(ordered_pair(V,W),U),X) ) ) ).

fof(rotate,axiom,
    ! [X] : subclass(rotate(X),cross_product(cross_product(universal_class,universal_class),universal_class)) ).

%----Axiom B-8: Existence of flip (not explicitly defined in Goedel)
fof(flip_defn,axiom,
    ! [U,V,W,X] :
      ( member(ordered_pair(ordered_pair(U,V),W),flip(X))
    <=> ( member(ordered_pair(ordered_pair(U,V),W),cross_product(cross_product(universal_class,universal_class),universal_class))
        & member(ordered_pair(ordered_pair(V,U),W),X) ) ) ).

fof(flip,axiom,
    ! [X] : subclass(flip(X),cross_product(cross_product(universal_class,universal_class),universal_class)) ).

%----I have removed the definitions of range and domain to SET005+1
%----as they are not needed for Goedel's axioms.

%----Plaisted's definition of union. Needed for successor
fof(union_defn,axiom,
    ! [X,Y,Z] :
      ( member(Z,union(X,Y))
    <=> ( member(Z,X)
        | member(Z,Y) ) ) ).

%----This is Quaife's original definition of union, which David Plaisted
%----suggested is unnatural ...
% input_formula(union_defn_quaife,axiom,(
%     ! [X,Y] : equal(union(X,Y),complement(intersection(complement(X),
% complement(Y))))   )).
%----Quaife's definition can be shown equivalent Plaisted's by showing each is
%----equivalent to this one ...
% input_formula(union_defn_geoff,axiom,(
%     ! [X,Y,Z] :
%       ( member(Z,union(X,Y))
%     <=> member(Z,complement(intersection(complement(X),complement(Y)))))   )).
%----as an intermediate

%----Definition of successor. Needed for successor_relation
fof(successor_defn,axiom,
    ! [X] : successor(X) = union(X,singleton(X)) ).

%----Definition of successor_relation. Needed for inductive.
fof(successor_relation_defn1,axiom,
    subclass(successor_relation,cross_product(universal_class,universal_class)) ).

%----This undoes the Quaife simplification from book p.28 Section 3.4
fof(successor_relation_defn2,axiom,
    ! [X,Y] :
      ( member(ordered_pair(X,Y),successor_relation)
    <=> ( member(X,universal_class)
        & member(Y,universal_class)
        & successor(X) = Y ) ) ).

%----Definition of inverse (not explicitly defined in Goedel)
%----Needed for range_of
fof(inverse_defn,axiom,
    ! [Y] : inverse(Y) = domain_of(flip(cross_product(Y,universal_class))) ).

%----Definition of range_of. Needed for image.
fof(range_of_defn,axiom,
    ! [Z] : range_of(Z) = domain_of(inverse(Z)) ).

%----Definition of image. Needed for inductive.
fof(image_defn,axiom,
    ! [X,XR] : image(XR,X) = range_of(restrict(XR,X,universal_class)) ).

%----Definition of inductive. Needed for C-1: Infinity
fof(inductive_defn,axiom,
    ! [X] :
      ( inductive(X)
    <=> ( member(null_class,X)
        & subclass(image(successor_relation,X),X) ) ) ).

%----Axiom C-1: Infinity
fof(infinity,axiom,
    ? [X] :
      ( member(X,universal_class)
      & inductive(X)
      & ! [Y] :
          ( inductive(Y)
         => subclass(X,Y) ) ) ).

%----Axiom C-2: Sum_class (not explicitly defined in Goedel)
fof(sum_class_defn,axiom,
    ! [U,X] :
      ( member(U,sum_class(X))
    <=> ? [Y] :
          ( member(U,Y)
          & member(Y,X) ) ) ).

%----Here is Quaife's original definition of sum_class, which David Plaisted
%----suggested is unnatural ...
%input_formula(sum_class_defn,axiom,(
%    ! [X] : equal(sum_class(X),domain_of(restrict(element_relation,
%universal_class,X)))   )).
%----Yunshan Zhu's sum class definition above has been shown equivalent to
%----the original by a longish sequence of equivalences. Boyer et al. also
%----use (a more complicated version of) the above definition.

fof(sum_class,axiom,
    ! [X] :
      ( member(X,universal_class)
     => member(sum_class(X),universal_class) ) ).

%----Axiom C-3: Existence of power_class (not explicitly defined in Goedel)
fof(power_class_defn,axiom,
    ! [U,X] :
      ( member(U,power_class(X))
    <=> ( member(U,universal_class)
        & subclass(U,X) ) ) ).

%----Here is Quaife's original definition of power_class, which David Plaisted
%----suggested is unnatural ...
%input_formula(power_class_defn,axiom,(
%    ! [X] : equal(power_class(X),complement(image(element_relation,
%complement(X))))   )).

fof(power_class,axiom,
    ! [U] :
      ( member(U,universal_class)
     => member(power_class(U),universal_class) ) ).

%----Definition of compose. Needed for function
fof(compose_defn1,axiom,
    ! [XR,YR] : subclass(compose(YR,XR),cross_product(universal_class,universal_class)) ).

%----This undoes the Quaife simplification from book p.28 Section 3.4, and
%----then simplifies that by removing a member(V,universal_class) from the RHS
fof(compose_defn2,axiom,
    ! [XR,YR,U,V] :
      ( member(ordered_pair(U,V),compose(YR,XR))
    <=> ( member(U,universal_class)
        & member(V,image(YR,image(XR,singleton(U)))) ) ) ).

%----Definition of single_valued_class. Needed for function
%----Quaife suggests not using this, in his book p.35
%input_formula(single_valued_class_defn,axiom,(
%    ! [X] :
%      ( single_valued_class(X)
%    <=> subclass(compose(X,inverse(X)),identity_relation) )   )).

%----Added definition of identity_relation (missing from Quaife)
fof(identity_relation,axiom,
    ! [Z] :
      ( member(Z,identity_relation)
    <=> ? [X] :
          ( member(X,universal_class)
          & Z = ordered_pair(X,X) ) ) ).

%----Definition of function. Needed for C-4: replacement
fof(function_defn,axiom,
    ! [XF] :
      ( function(XF)
    <=> ( subclass(XF,cross_product(universal_class,universal_class))
        & subclass(compose(XF,inverse(XF)),identity_relation) ) ) ).

%----Axiom C-4: Replacement
fof(replacement,axiom,
    ! [X,XF] :
      ( ( member(X,universal_class)
        & function(XF) )
     => member(image(XF,X),universal_class) ) ).

%----Definition of disjoint. This is omitted by Quaife
fof(disjoint_defn,axiom,
    ! [X,Y] :
      ( disjoint(X,Y)
    <=> ! [U] :
          ~ ( member(U,X)
            & member(U,Y) ) ) ).

%----Axiom D: Regularity
%----This also provides a definition of the null_class of the form
%----! [X] : ( equal(X,null_class) <= ! [U] : ~ member(U,X) )
fof(regularity,axiom,
    ! [X] :
      ( X != null_class
     => ? [U] :
          ( member(U,universal_class)
          & member(U,X)
          & disjoint(U,X) ) ) ).

%----Definition of apply. Needed for universal choice
fof(apply_defn,axiom,
    ! [XF,Y] : apply(XF,Y) = sum_class(image(XF,singleton(Y))) ).

%----Axiom E: Universal choice
fof(choice,axiom,
    ? [XF] :
      ( function(XF)
      & ! [Y] :
          ( member(Y,universal_class)
         => ( Y = null_class
            | member(apply(XF,Y),Y) ) ) ) ).

%--------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET006+0 : TPTP v9.0.0. Released v2.2.0.
% Domain   : Set Theory
% Axioms   : Naive set theory based on Goedel's set theory
% Version  : [Pas99] axioms.
% English  :

% Refs     : [Pas99] Pastre (1999), Email to G. Sutcliffe
% Source   : [Pas99]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of formulae    :   11 (   1 unt;   0 def)
%            Number of atoms       :   29 (   3 equ)
%            Maximal formula atoms :    3 (   2 avg)
%            Number of connectives :   20 (   2   ~;   2   |;   4   &)
%                                         (  10 <=>;   2  =>;   0  <=;   0 <~>)
%            Maximal formula depth :    7 (   5 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    4 (   3 usr;   0 prp; 2-2 aty)
%            Number of functors    :    9 (   9 usr;   1 con; 0-2 aty)
%            Number of variables   :   28 (  27   !;   1   ?)
% SPC      : 

% Comments :
%------------------------------------------------------------------------------
%----Axioms of operations on sets
fof(subset,axiom,
    ! [A,B] :
      ( subset(A,B)
    <=> ! [X] :
          ( member(X,A)
         => member(X,B) ) ) ).

fof(equal_set,axiom,
    ! [A,B] :
      ( equal_set(A,B)
    <=> ( subset(A,B)
        & subset(B,A) ) ) ).

fof(power_set,axiom,
    ! [X,A] :
      ( member(X,power_set(A))
    <=> subset(X,A) ) ).

fof(intersection,axiom,
    ! [X,A,B] :
      ( member(X,intersection(A,B))
    <=> ( member(X,A)
        & member(X,B) ) ) ).

fof(union,axiom,
    ! [X,A,B] :
      ( member(X,union(A,B))
    <=> ( member(X,A)
        | member(X,B) ) ) ).

fof(empty_set,axiom,
    ! [X] : ~ member(X,empty_set) ).

fof(difference,axiom,
    ! [B,A,E] :
      ( member(B,difference(E,A))
    <=> ( member(B,E)
        & ~ member(B,A) ) ) ).

fof(singleton,axiom,
    ! [X,A] :
      ( member(X,singleton(A))
    <=> X = A ) ).

fof(unordered_pair,axiom,
    ! [X,A,B] :
      ( member(X,unordered_pair(A,B))
    <=> ( X = A
        | X = B ) ) ).

fof(sum,axiom,
    ! [X,A] :
      ( member(X,sum(A))
    <=> ? [Y] :
          ( member(Y,A)
          & member(X,Y) ) ) ).

fof(product,axiom,
    ! [X,A] :
      ( member(X,product(A))
    <=> ! [Y] :
          ( member(Y,A)
         => member(X,Y) ) ) ).

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET006+1 : TPTP v9.0.0. Bugfixed v2.2.1.
% Domain   : Set Theory
% Axioms   : Mapping axioms for the SET006+0 set theory axioms
% Version  : [Pas99] axioms.
% English  :

% Refs     : [Pas99] Pastre (1999), Email to G. Sutcliffe
% Source   : [Pas99]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of formulae    :   17 (   0 unt;   0 def)
%            Number of atoms       :   99 (   3 equ)
%            Maximal formula atoms :   11 (   5 avg)
%            Number of connectives :   82 (   0   ~;   0   |;  46   &)
%                                         (  20 <=>;  16  =>;   0  <=;   0 <~>)
%            Maximal formula depth :   19 (  11 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :   14 (  13 usr;   0 prp; 2-6 aty)
%            Number of functors    :    6 (   6 usr;   0 con; 2-5 aty)
%            Number of variables   :  105 (  97   !;   8   ?)
% SPC      : 

% Comments : Requires SET006+0.ax
% Bugfixes : v2.2.1 - compose_function and inverse_function fixed.
%------------------------------------------------------------------------------
%----Axiom and properties of mappings
fof(maps,axiom,
    ! [F,A,B] :
      ( maps(F,A,B)
    <=> ( ! [X] :
            ( member(X,A)
           => ? [Y] :
                ( member(Y,B)
                & apply(F,X,Y) ) )
        & ! [X,Y1,Y2] :
            ( ( member(X,A)
              & member(Y1,B)
              & member(Y2,B) )
           => ( ( apply(F,X,Y1)
                & apply(F,X,Y2) )
             => Y1 = Y2 ) ) ) ) ).

fof(compose_predicate,axiom,
    ! [H,G,F,A,B,C] :
      ( compose_predicate(H,G,F,A,B,C)
    <=> ! [X,Z] :
          ( ( member(X,A)
            & member(Z,C) )
         => ( apply(H,X,Z)
          <=> ? [Y] :
                ( member(Y,B)
                & apply(F,X,Y)
                & apply(G,Y,Z) ) ) ) ) ).

fof(compose_function,axiom,
    ! [G,F,A,B,C,X,Z] :
      ( ( member(X,A)
        & member(Z,C) )
     => ( apply(compose_function(G,F,A,B,C),X,Z)
      <=> ? [Y] :
            ( member(Y,B)
            & apply(F,X,Y)
            & apply(G,Y,Z) ) ) ) ).

fof(equal_maps,axiom,
    ! [F,G,A,B] :
      ( equal_maps(F,G,A,B)
    <=> ! [X,Y1,Y2] :
          ( ( member(X,A)
            & member(Y1,B)
            & member(Y2,B) )
         => ( ( apply(F,X,Y1)
              & apply(G,X,Y2) )
           => Y1 = Y2 ) ) ) ).

fof(identity,axiom,
    ! [F,A] :
      ( identity(F,A)
    <=> ! [X] :
          ( member(X,A)
         => apply(F,X,X) ) ) ).

fof(injective,axiom,
    ! [F,A,B] :
      ( injective(F,A,B)
    <=> ! [X1,X2,Y] :
          ( ( member(X1,A)
            & member(X2,A)
            & member(Y,B) )
         => ( ( apply(F,X1,Y)
              & apply(F,X2,Y) )
           => X1 = X2 ) ) ) ).

fof(surjective,axiom,
    ! [F,A,B] :
      ( surjective(F,A,B)
    <=> ! [Y] :
          ( member(Y,B)
         => ? [E] :
              ( member(E,A)
              & apply(F,E,Y) ) ) ) ).

fof(one_to_one,axiom,
    ! [F,A,B] :
      ( one_to_one(F,A,B)
    <=> ( injective(F,A,B)
        & surjective(F,A,B) ) ) ).

fof(inverse_predicate,axiom,
    ! [G,F,A,B] :
      ( inverse_predicate(G,F,A,B)
    <=> ! [X,Y] :
          ( ( member(X,A)
            & member(Y,B) )
         => ( apply(F,X,Y)
          <=> apply(G,Y,X) ) ) ) ).

fof(inverse_function,axiom,
    ! [F,A,B,X,Y] :
      ( ( member(X,A)
        & member(Y,B) )
     => ( apply(F,X,Y)
      <=> apply(inverse_function(F,A,B),Y,X) ) ) ).

fof(image2,axiom,
    ! [F,A,Y] :
      ( member(Y,image2(F,A))
    <=> ? [X] :
          ( member(X,A)
          & apply(F,X,Y) ) ) ).

fof(image3,axiom,
    ! [F,A,B,Y] :
      ( member(Y,image3(F,A,B))
    <=> ( member(Y,B)
        & ? [X] :
            ( member(X,A)
            & apply(F,X,Y) ) ) ) ).

fof(inverse_image2,axiom,
    ! [F,B,X] :
      ( member(X,inverse_image2(F,B))
    <=> ? [Y] :
          ( member(Y,B)
          & apply(F,X,Y) ) ) ).

fof(inverse_image3,axiom,
    ! [F,B,A,X] :
      ( member(X,inverse_image3(F,B,A))
    <=> ( member(X,A)
        & ? [Y] :
            ( member(Y,B)
            & apply(F,X,Y) ) ) ) ).

fof(increasing_function,axiom,
    ! [F,A,R,B,S] :
      ( increasing(F,A,R,B,S)
    <=> ! [X1,Y1,X2,Y2] :
          ( ( member(X1,A)
            & member(Y1,B)
            & member(X2,A)
            & member(Y2,B)
            & apply(R,X1,X2)
            & apply(F,X1,Y1)
            & apply(F,X2,Y2) )
         => apply(S,Y1,Y2) ) ) ).

fof(decreasing_function,axiom,
    ! [F,A,R,B,S] :
      ( decreasing(F,A,R,B,S)
    <=> ! [X1,Y1,X2,Y2] :
          ( ( member(X1,A)
            & member(Y1,B)
            & member(X2,A)
            & member(Y2,B)
            & apply(R,X1,X2)
            & apply(F,X1,Y1)
            & apply(F,X2,Y2) )
         => apply(S,Y2,Y1) ) ) ).

fof(isomorphism,axiom,
    ! [F,A,R,B,S] :
      ( isomorphism(F,A,R,B,S)
    <=> ( maps(F,A,B)
        & one_to_one(F,A,B)
        & ! [X1,Y1,X2,Y2] :
            ( ( member(X1,A)
              & member(Y1,B)
              & member(X2,A)
              & member(Y2,B)
              & apply(F,X1,Y1)
              & apply(F,X2,Y2) )
           => ( apply(R,X1,X2)
            <=> apply(S,Y1,Y2) ) ) ) ) ).

%------------------------------------------------------------------------------
%--------------------------------------------------------------------------
% File     : SET006+2 : TPTP v9.0.0. Released v2.2.0.
% Domain   : Set Theory
% Axioms   : Equivalence relation axioms for the SET006+0 set theory axioms
% Version  : [Pas99] axioms.
% English  :

% Refs     : [Pas99] Pastre (1999), Email to G. Sutcliffe
% Source   : [Pas99]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of formulae    :    5 (   0 unt;   0 def)
%            Number of atoms       :   39 (   1 equ)
%            Maximal formula atoms :   13 (   7 avg)
%            Number of connectives :   35 (   1   ~;   0   |;  17   &)
%                                         (   5 <=>;  12  =>;   0  <=;   0 <~>)
%            Maximal formula depth :   12 (  10 avg)
%            Maximal term depth    :    2 (   1 avg)
%            Number of predicates  :    8 (   7 usr;   0 prp; 2-3 aty)
%            Number of functors    :    1 (   1 usr;   0 con; 3-3 aty)
%            Number of variables   :   29 (  26   !;   3   ?)
% SPC      : 

% Comments : Requires SET006+0.ax
%--------------------------------------------------------------------------
%----Equivalence relations
fof(disjoint,axiom,
    ! [A,B] :
      ( disjoint(A,B)
    <=> ~ ? [X] :
            ( member(X,A)
            & member(X,B) ) ) ).

fof(partition,axiom,
    ! [A,E] :
      ( partition(A,E)
    <=> ( ! [X] :
            ( member(X,A)
           => subset(X,E) )
        & ! [X] :
            ( member(X,E)
           => ? [Y] :
                ( member(Y,A)
                & member(X,Y) ) )
        & ! [X,Y] :
            ( ( member(X,A)
              & member(Y,A) )
           => ( ? [Z] :
                  ( member(Z,X)
                  & member(Z,Y) )
             => X = Y ) ) ) ) ).

fof(equivalence,axiom,
    ! [A,R] :
      ( equivalence(R,A)
    <=> ( ! [X] :
            ( member(X,A)
           => apply(R,X,X) )
        & ! [X,Y] :
            ( ( member(X,A)
              & member(Y,A) )
           => ( apply(R,X,Y)
             => apply(R,Y,X) ) )
        & ! [X,Y,Z] :
            ( ( member(X,A)
              & member(Y,A)
              & member(Z,A) )
           => ( ( apply(R,X,Y)
                & apply(R,Y,Z) )
             => apply(R,X,Z) ) ) ) ) ).

fof(equivalence_class,axiom,
    ! [R,E,A,X] :
      ( member(X,equivalence_class(A,E,R))
    <=> ( member(X,E)
        & apply(R,A,X) ) ) ).

fof(pre_order,axiom,
    ! [R,E] :
      ( pre_order(R,E)
    <=> ( ! [X] :
            ( member(X,E)
           => apply(R,X,X) )
        & ! [X,Y,Z] :
            ( ( member(X,E)
              & member(Y,E)
              & member(Z,E) )
           => ( ( apply(R,X,Y)
                & apply(R,Y,Z) )
             => apply(R,X,Z) ) ) ) ) ).

%--------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET006+3 : TPTP v9.0.0. Released v3.2.0.
% Domain   : Set Theory
% Axioms   : Order relation (Naive set theory)
% Version  : [Pas05] axioms.
% English  :

% Refs     : [Pas05] Pastre (2005), Email to G. Sutcliffe
% Source   : [Pas05]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of formulae    :   10 (   0 unt;   0 def)
%            Number of atoms       :   56 (   3 equ)
%            Maximal formula atoms :   14 (   5 avg)
%            Number of connectives :   46 (   0   ~;   1   |;  21   &)
%                                         (  10 <=>;  14  =>;   0  <=;   0 <~>)
%            Maximal formula depth :   12 (   9 avg)
%            Maximal term depth    :    1 (   1 avg)
%            Number of predicates  :   13 (  12 usr;   0 prp; 2-4 aty)
%            Number of functors    :    0 (   0 usr;   0 con; --- aty)
%            Number of variables   :   46 (  46   !;   0   ?)
% SPC      : 

% Comments : Requires SET006+0.ax
%------------------------------------------------------------------------------
%----Order relations
fof(order,axiom,
    ! [R,E] :
      ( order(R,E)
    <=> ( ! [X] :
            ( member(X,E)
           => apply(R,X,X) )
        & ! [X,Y] :
            ( ( member(X,E)
              & member(Y,E) )
           => ( ( apply(R,X,Y)
                & apply(R,Y,X) )
             => X = Y ) )
        & ! [X,Y,Z] :
            ( ( member(X,E)
              & member(Y,E)
              & member(Z,E) )
           => ( ( apply(R,X,Y)
                & apply(R,Y,Z) )
             => apply(R,X,Z) ) ) ) ) ).

fof(total_order,axiom,
    ! [R,E] :
      ( total_order(R,E)
    <=> ( order(R,E)
        & ! [X,Y] :
            ( ( member(X,E)
              & member(Y,E) )
           => ( apply(R,X,Y)
              | apply(R,Y,X) ) ) ) ) ).

fof(upper_bound,axiom,
    ! [R,E,M] :
      ( upper_bound(M,R,E)
    <=> ! [X] :
          ( member(X,E)
         => apply(R,X,M) ) ) ).

fof(lower_bound,axiom,
    ! [R,E,M] :
      ( lower_bound(M,R,E)
    <=> ! [X] :
          ( member(X,E)
         => apply(R,M,X) ) ) ).

fof(greatest,axiom,
    ! [R,E,M] :
      ( greatest(M,R,E)
    <=> ( member(M,E)
        & ! [X] :
            ( member(X,E)
           => apply(R,X,M) ) ) ) ).

fof(least,axiom,
    ! [R,E,M] :
      ( least(M,R,E)
    <=> ( member(M,E)
        & ! [X] :
            ( member(X,E)
           => apply(R,M,X) ) ) ) ).

fof(max,axiom,
    ! [R,E,M] :
      ( max(M,R,E)
    <=> ( member(M,E)
        & ! [X] :
            ( ( member(X,E)
              & apply(R,M,X) )
           => M = X ) ) ) ).

fof(min,axiom,
    ! [R,E,M] :
      ( min(M,R,E)
    <=> ( member(M,E)
        & ! [X] :
            ( ( member(X,E)
              & apply(R,X,M) )
           => M = X ) ) ) ).

fof(least_upper_bound,axiom,
    ! [A,X,R,E] :
      ( least_upper_bound(A,X,R,E)
    <=> ( member(A,X)
        & upper_bound(A,R,X)
        & ! [M] :
            ( ( member(M,E)
              & upper_bound(M,R,X) )
           => apply(R,A,M) ) ) ) ).

fof(greatest_lower_bound,axiom,
    ! [A,X,R,E] :
      ( greatest_lower_bound(A,X,R,E)
    <=> ( member(A,X)
        & lower_bound(A,R,X)
        & ! [M] :
            ( ( member(M,E)
              & lower_bound(M,R,X) )
           => apply(R,M,A) ) ) ) ).

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET006+4 : TPTP v9.0.0. Released v3.2.0.
% Domain   : Set Theory
% Axioms   : Ordinal numbers for the SET006+0 set theory axioms
% Version  : [Pas05] axioms.
% English  :

% Refs     : [Pas05] Pastre (2005), Email to G. Sutcliffe
% Source   : [Pas05]
% Names    :

% Status   : Satisfiable
% Syntax   : Number of formulae    :    8 (   0 unt;   0 def)
%            Number of atoms       :   36 (   1 equ)
%            Maximal formula atoms :   11 (   4 avg)
%            Number of connectives :   29 (   1   ~;   1   |;  12   &)
%                                         (   7 <=>;   8  =>;   0  <=;   0 <~>)
%            Maximal formula depth :   11 (   7 avg)
%            Maximal term depth    :    3 (   1 avg)
%            Number of predicates  :    8 (   7 usr;   0 prp; 1-3 aty)
%            Number of functors    :    6 (   6 usr;   2 con; 0-3 aty)
%            Number of variables   :   28 (  26   !;   2   ?)
% SPC      : 

% Comments : Requires SET006+0.ax
%------------------------------------------------------------------------------
%---- Ordinal numbers and strict order relations
fof(ordinal_number,axiom,
    ! [A] :
      ( member(A,on)
    <=> ( set(A)
        & strict_well_order(member_predicate,A)
        & ! [X] :
            ( member(X,A)
           => subset(X,A) ) ) ) ).

fof(strict_well_order,axiom,
    ! [R,E] :
      ( strict_well_order(R,E)
    <=> ( strict_order(R,E)
        & ! [A] :
            ( ( subset(A,E)
              & ? [X] : member(X,A) )
           => ? [Y] : least(Y,R,A) ) ) ) ).

fof(least,axiom,
    ! [R,E,M] :
      ( least(M,R,E)
    <=> ( member(M,E)
        & ! [X] :
            ( member(X,E)
           => ( M = X
              | apply(R,M,X) ) ) ) ) ).

fof(rel_member,axiom,
    ! [X,Y] :
      ( apply(member_predicate,X,Y)
    <=> member(X,Y) ) ).

fof(strict_order,axiom,
    ! [R,E] :
      ( strict_order(R,E)
    <=> ( ! [X,Y] :
            ( ( member(X,E)
              & member(Y,E) )
           => ~ ( apply(R,X,Y)
                & apply(R,Y,X) ) )
        & ! [X,Y,Z] :
            ( ( member(X,E)
              & member(Y,E)
              & member(Z,E) )
           => ( ( apply(R,X,Y)
                & apply(R,Y,Z) )
             => apply(R,X,Z) ) ) ) ) ).

fof(set_member,axiom,
    ! [X] :
      ( set(X)
     => ! [Y] :
          ( member(Y,X)
         => set(Y) ) ) ).

fof(initial_segment,axiom,
    ! [X,R,A,Y] :
      ( member(Y,initial_segment(X,R,A))
    <=> ( member(Y,A)
        & apply(R,Y,X) ) ) ).

fof(successor,axiom,
    ! [A,X] :
      ( member(X,suc(A))
    <=> member(X,union(A,singleton(A))) ) ).

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET008^0 : TPTP v9.0.0. Released v3.6.0.
% Domain   : Set Theory
% Axioms   : Basic set theory definitions
% Version  : [Ben08] axioms.
% English  :

% Refs     : [BS+05] Benzmueller et al. (2005), Can a Higher-Order and a Fi
%          : [BS+08] Benzmueller et al. (2007), Combined Reasoning by Autom
%          : [Ben08] Benzmueller (2008), Email to Geoff Sutcliffe
% Source   : [Ben08]
% Names    : Typed_Set [Ben08]

% Status   : Satisfiable
% Syntax   : Number of formulae    :   28 (  14 unt;  14 typ;  14 def)
%            Number of atoms       :   35 (  18 equ;   0 cnn)
%            Maximal formula atoms :    1 (   1 avg)
%            Number of connectives :   36 (   5   ~;   3   |;   6   &;  21   @)
%                                         (   0 <=>;   1  =>;   0  <=;   0 <~>)
%            Maximal formula depth :    1 (   1 avg;  21 nst)
%            Number of types       :    2 (   0 usr)
%            Number of type conns  :   70 (  70   >;   0   *;   0   +;   0  <<)
%            Number of symbols     :   16 (  14 usr;   1 con; 0-3 aty)
%            Number of variables   :   35 (  32   ^   1   !;   2   ?;  35   :)
% SPC      : 

% Comments :
%------------------------------------------------------------------------------
thf(in_decl,type,
    in: $i > ( $i > $o ) > $o ).

thf(in,definition,
    ( in
    = ( ^ [X: $i,M: $i > $o] : ( M @ X ) ) ) ).

thf(is_a_decl,type,
    is_a: $i > ( $i > $o ) > $o ).

thf(is_a,definition,
    ( is_a
    = ( ^ [X: $i,M: $i > $o] : ( M @ X ) ) ) ).

thf(emptyset_decl,type,
    emptyset: $i > $o ).

thf(emptyset,definition,
    ( emptyset
    = ( ^ [X: $i] : $false ) ) ).

thf(unord_pair_decl,type,
    unord_pair: $i > $i > $i > $o ).

thf(unord_pair,definition,
    ( unord_pair
    = ( ^ [X: $i,Y: $i,U: $i] :
          ( ( U = X )
          | ( U = Y ) ) ) ) ).

thf(singleton_decl,type,
    singleton: $i > $i > $o ).

thf(singleton,definition,
    ( singleton
    = ( ^ [X: $i,U: $i] : ( U = X ) ) ) ).

thf(union_decl,type,
    union: ( $i > $o ) > ( $i > $o ) > $i > $o ).

thf(union,definition,
    ( union
    = ( ^ [X: $i > $o,Y: $i > $o,U: $i] :
          ( ( X @ U )
          | ( Y @ U ) ) ) ) ).

thf(excl_union_decl,type,
    excl_union: ( $i > $o ) > ( $i > $o ) > $i > $o ).

thf(excl_union,definition,
    ( excl_union
    = ( ^ [X: $i > $o,Y: $i > $o,U: $i] :
          ( ( ( X @ U )
            & ~ ( Y @ U ) )
          | ( ~ ( X @ U )
            & ( Y @ U ) ) ) ) ) ).

thf(intersection_decl,type,
    intersection: ( $i > $o ) > ( $i > $o ) > $i > $o ).

thf(intersection,definition,
    ( intersection
    = ( ^ [X: $i > $o,Y: $i > $o,U: $i] :
          ( ( X @ U )
          & ( Y @ U ) ) ) ) ).

thf(setminus_decl,type,
    setminus: ( $i > $o ) > ( $i > $o ) > $i > $o ).

thf(setminus,definition,
    ( setminus
    = ( ^ [X: $i > $o,Y: $i > $o,U: $i] :
          ( ( X @ U )
          & ~ ( Y @ U ) ) ) ) ).

thf(complement_decl,type,
    complement: ( $i > $o ) > $i > $o ).

thf(complement,definition,
    ( complement
    = ( ^ [X: $i > $o,U: $i] :
          ~ ( X @ U ) ) ) ).

thf(disjoint_decl,type,
    disjoint: ( $i > $o ) > ( $i > $o ) > $o ).

thf(disjoint,definition,
    ( disjoint
    = ( ^ [X: $i > $o,Y: $i > $o] :
          ( ( intersection @ X @ Y )
          = emptyset ) ) ) ).

thf(subset_decl,type,
    subset: ( $i > $o ) > ( $i > $o ) > $o ).

thf(subset,definition,
    ( subset
    = ( ^ [X: $i > $o,Y: $i > $o] :
        ! [U: $i] :
          ( ( X @ U )
         => ( Y @ U ) ) ) ) ).

thf(meets_decl,type,
    meets: ( $i > $o ) > ( $i > $o ) > $o ).

thf(meets,definition,
    ( meets
    = ( ^ [X: $i > $o,Y: $i > $o] :
        ? [U: $i] :
          ( ( X @ U )
          & ( Y @ U ) ) ) ) ).

thf(misses_decl,type,
    misses: ( $i > $o ) > ( $i > $o ) > $o ).

thf(misses,definition,
    ( misses
    = ( ^ [X: $i > $o,Y: $i > $o] :
          ~ ? [U: $i] :
              ( ( X @ U )
              & ( Y @ U ) ) ) ) ).

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET008^1 : TPTP v9.0.0. Released v3.6.0.
% Domain   : Set Theory
% Axioms   : Definitions for functions
% Version  : [Ben08] axioms.
% English  :

% Refs     : [BS+05] Benzmueller et al. (2005), Can a Higher-Order and a Fi
%          : [BS+08] Benzmueller et al. (2007), Combined Reasoning by Autom
%          : [Ben08] Benzmueller (2008), Email to Geoff Sutcliffe
% Source   : [Ben08]
% Names    : Typed_Function [Ben08]

% Status   : Satisfiable
% Syntax   : Number of formulae    :   16 (   8 unt;   8 typ;   8 def)
%            Number of atoms       :   22 (  13 equ;   0 cnn)
%            Maximal formula atoms :    1 (   1 avg)
%            Number of connectives :   29 (   0   ~;   0   |;   3   &;  23   @)
%                                         (   0 <=>;   3  =>;   0  <=;   0 <~>)
%            Maximal formula depth :    1 (   1 avg;  23 nst)
%            Number of types       :    2 (   0 usr)
%            Number of type conns  :   46 (  46   >;   0   *;   0   +;   0  <<)
%            Number of symbols     :    9 (   8 usr;   0 con; 1-3 aty)
%            Number of variables   :   26 (  16   ^   7   !;   3   ?;  26   :)
% SPC      : 

% Comments : Requires SET008^0.
%------------------------------------------------------------------------------
thf(fun_image_decl,type,
    fun_image: ( $i > $i ) > ( $i > $o ) > $i > $o ).

thf(fun_image,definition,
    ( fun_image
    = ( ^ [F: $i > $i,A: $i > $o,Y: $i] :
        ? [X: $i] :
          ( ( A @ X )
          & ( Y
            = ( F @ X ) ) ) ) ) ).

thf(fun_composition_decl,type,
    fun_composition: ( $i > $i ) > ( $i > $i ) > $i > $i ).

thf(fun_composition,definition,
    ( fun_composition
    = ( ^ [F: $i > $i,G: $i > $i,X: $i] : ( G @ ( F @ X ) ) ) ) ).

thf(fun_inv_image_decl,type,
    fun_inv_image: ( $i > $i ) > ( $i > $o ) > $i > $o ).

thf(fun_inv_image,definition,
    ( fun_inv_image
    = ( ^ [F: $i > $i,B: $i > $o,X: $i] :
        ? [Y: $i] :
          ( ( B @ Y )
          & ( Y
            = ( F @ X ) ) ) ) ) ).

thf(fun_injective_decl,type,
    fun_injective: ( $i > $i ) > $o ).

thf(fun_injective,definition,
    ( fun_injective
    = ( ^ [F: $i > $i] :
        ! [X: $i,Y: $i] :
          ( ( ( F @ X )
            = ( F @ Y ) )
         => ( X = Y ) ) ) ) ).

thf(fun_surjective_decl,type,
    fun_surjective: ( $i > $i ) > $o ).

thf(fun_surjective,definition,
    ( fun_surjective
    = ( ^ [F: $i > $i] :
        ! [Y: $i] :
        ? [X: $i] :
          ( Y
          = ( F @ X ) ) ) ) ).

thf(fun_bijective_decl,type,
    fun_bijective: ( $i > $i ) > $o ).

thf(fun_bijective,definition,
    ( fun_bijective
    = ( ^ [F: $i > $i] :
          ( ( fun_injective @ F )
          & ( fun_surjective @ F ) ) ) ) ).

thf(fun_decreasing_decl,type,
    fun_decreasing: ( $i > $i ) > ( $i > $i > $o ) > $o ).

thf(fun_decreasing,definition,
    ( fun_decreasing
    = ( ^ [F: $i > $i,SMALLER: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( SMALLER @ X @ Y )
         => ( SMALLER @ ( F @ Y ) @ ( F @ X ) ) ) ) ) ).

thf(fun_increasing_decl,type,
    fun_increasing: ( $i > $i ) > ( $i > $i > $o ) > $o ).

thf(fun_increasing,definition,
    ( fun_increasing
    = ( ^ [F: $i > $i,SMALLER: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( SMALLER @ X @ Y )
         => ( SMALLER @ ( F @ X ) @ ( F @ Y ) ) ) ) ) ).

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET008^2 : TPTP v9.0.0. Released v3.6.0.
% Domain   : Set Theory
% Axioms   : Definitions for relations
% Version  : [Ben08] axioms.
% English  :

% Refs     : [BS+05] Benzmueller et al. (2005), Can a Higher-Order and a Fi
%          : [BS+08] Benzmueller et al. (2007), Combined Reasoning by Autom
%          : [Ben08] Benzmueller (2008), Email to Geoff Sutcliffe
% Source   : [Ben08]
% Names    : Typed_Relation [Ben08]

% Status   : Satisfiable
% Syntax   : Number of formulae    :   42 (  21 unt;  21 typ;  21 def)
%            Number of atoms       :   51 (  25 equ;   0 cnn)
%            Maximal formula atoms :    1 (   1 avg)
%            Number of connectives :   88 (   3   ~;   2   |;  12   &;  62   @)
%                                         (   1 <=>;   8  =>;   0  <=;   0 <~>)
%            Maximal formula depth :    1 (   1 avg;  62 nst)
%            Number of types       :    2 (   0 usr)
%            Number of type conns  :  142 ( 142   >;   0   *;   0   +;   0  <<)
%            Number of symbols     :   22 (  21 usr;   0 con; 1-4 aty)
%            Number of variables   :   72 (  48   ^  18   !;   6   ?;  72   :)
% SPC      : 

% Comments : Requires SET008^0.
%------------------------------------------------------------------------------
thf(cartesian_product_decl,type,
    cartesian_product: ( $i > $o ) > ( $i > $o ) > $i > $i > $o ).

thf(cartesian_product,definition,
    ( cartesian_product
    = ( ^ [X: $i > $o,Y: $i > $o,U: $i,V: $i] :
          ( ( X @ U )
          & ( Y @ V ) ) ) ) ).

thf(pair_rel_decl,type,
    pair_rel: $i > $i > $i > $i > $o ).

thf(pair_rel,definition,
    ( pair_rel
    = ( ^ [X: $i,Y: $i,U: $i,V: $i] :
          ( ( U = X )
          | ( V = Y ) ) ) ) ).

thf(id_rel_decl,type,
    id_rel: ( $i > $o ) > $i > $i > $o ).

thf(id_rel,definition,
    ( id_rel
    = ( ^ [S: $i > $o,X: $i,Y: $i] :
          ( ( S @ X )
          & ( X = Y ) ) ) ) ).

thf(sub_rel_decl,type,
    sub_rel: ( $i > $i > $o ) > ( $i > $i > $o ) > $o ).

thf(sub_rel,definition,
    ( sub_rel
    = ( ^ [R1: $i > $i > $o,R2: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( R1 @ X @ Y )
         => ( R2 @ X @ Y ) ) ) ) ).

thf(is_rel_on_decl,type,
    is_rel_on: ( $i > $i > $o ) > ( $i > $o ) > ( $i > $o ) > $o ).

thf(is_rel_on,definition,
    ( is_rel_on
    = ( ^ [R: $i > $i > $o,A: $i > $o,B: $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( R @ X @ Y )
         => ( ( A @ X )
            & ( B @ Y ) ) ) ) ) ).

thf(restrict_rel_domain_decl,type,
    restrict_rel_domain: ( $i > $i > $o ) > ( $i > $o ) > $i > $i > $o ).

thf(restrict_rel_domain,definition,
    ( restrict_rel_domain
    = ( ^ [R: $i > $i > $o,S: $i > $o,X: $i,Y: $i] :
          ( ( S @ X )
          & ( R @ X @ Y ) ) ) ) ).

thf(rel_diagonal_decl,type,
    rel_diagonal: $i > $i > $o ).

thf(rel_diagonal,definition,
    ( rel_diagonal
    = ( ^ [X: $i,Y: $i] : ( X = Y ) ) ) ).

thf(rel_composition_decl,type,
    rel_composition: ( $i > $i > $o ) > ( $i > $i > $o ) > $i > $i > $o ).

thf(rel_composition,definition,
    ( rel_composition
    = ( ^ [R1: $i > $i > $o,R2: $i > $i > $o,X: $i,Z: $i] :
        ? [Y: $i] :
          ( ( R1 @ X @ Y )
          & ( R2 @ Y @ Z ) ) ) ) ).

thf(reflexive_decl,type,
    reflexive: ( $i > $i > $o ) > $o ).

thf(reflexive,definition,
    ( reflexive
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i] : ( R @ X @ X ) ) ) ).

thf(irreflexive_decl,type,
    irreflexive: ( $i > $i > $o ) > $o ).

thf(irreflexive,definition,
    ( irreflexive
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i] :
          ~ ( R @ X @ X ) ) ) ).

thf(symmetric_decl,type,
    symmetric: ( $i > $i > $o ) > $o ).

thf(symmetric,definition,
    ( symmetric
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( R @ X @ Y )
         => ( R @ Y @ X ) ) ) ) ).

thf(transitive_decl,type,
    transitive: ( $i > $i > $o ) > $o ).

thf(transitive,definition,
    ( transitive
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i,Z: $i] :
          ( ( ( R @ X @ Y )
            & ( R @ Y @ Z ) )
         => ( R @ X @ Z ) ) ) ) ).

thf(equiv_rel__decl,type,
    equiv_rel: ( $i > $i > $o ) > $o ).

thf(equiv_rel,definition,
    ( equiv_rel
    = ( ^ [R: $i > $i > $o] :
          ( ( reflexive @ R )
          & ( symmetric @ R )
          & ( transitive @ R ) ) ) ) ).

thf(rel_codomain_decl,type,
    rel_codomain: ( $i > $i > $o ) > $i > $o ).

thf(rel_codomain,definition,
    ( rel_codomain
    = ( ^ [R: $i > $i > $o,Y: $i] :
        ? [X: $i] : ( R @ X @ Y ) ) ) ).

thf(rel_domain_decl,type,
    rel_domain: ( $i > $i > $o ) > $i > $o ).

thf(rel_domain,definition,
    ( rel_domain
    = ( ^ [R: $i > $i > $o,X: $i] :
        ? [Y: $i] : ( R @ X @ Y ) ) ) ).

thf(rel_inverse_decl,type,
    rel_inverse: ( $i > $i > $o ) > $i > $i > $o ).

thf(rel_inverse,definition,
    ( rel_inverse
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] : ( R @ Y @ X ) ) ) ).

thf(equiv_classes_decl,type,
    equiv_classes: ( $i > $i > $o ) > ( $i > $o ) > $o ).

thf(equiv_classes,definition,
    ( equiv_classes
    = ( ^ [R: $i > $i > $o,S1: $i > $o] :
        ? [X: $i] :
          ( ( S1 @ X )
          & ! [Y: $i] :
              ( ( S1 @ Y )
            <=> ( R @ X @ Y ) ) ) ) ) ).

thf(restrict_rel_codomain_decl,type,
    restrict_rel_codomain: ( $i > $i > $o ) > ( $i > $o ) > $i > $i > $o ).

thf(restrict_rel_codomain,definition,
    ( restrict_rel_codomain
    = ( ^ [R: $i > $i > $o,S: $i > $o,X: $i,Y: $i] :
          ( ( S @ Y )
          & ( R @ X @ Y ) ) ) ) ).

thf(rel_field_decl,type,
    rel_field: ( $i > $i > $o ) > $i > $o ).

thf(rel_field,definition,
    ( rel_field
    = ( ^ [R: $i > $i > $o,X: $i] :
          ( ( rel_domain @ R @ X )
          | ( rel_codomain @ R @ X ) ) ) ) ).

thf(well_founded_decl,type,
    well_founded: ( $i > $i > $o ) > $o ).

thf(well_founded,definition,
    ( well_founded
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i > $o,Z: $i] :
          ( ( X @ Z )
         => ? [Y: $i] :
              ( ( X @ Y )
              & ! [W: $i] :
                  ( ( R @ Y @ W )
                 => ~ ( X @ W ) ) ) ) ) ) ).

thf(upwards_well_founded_decl,type,
    upwards_well_founded: ( $i > $i > $o ) > $o ).

thf(upwards_well_founded,definition,
    ( upwards_well_founded
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i > $o,Z: $i] :
          ( ( X @ Z )
         => ? [Y: $i] :
              ( ( X @ Y )
              & ! [W: $i] :
                  ( ( R @ Y @ Y )
                 => ~ ( X @ W ) ) ) ) ) ) ).

%------------------------------------------------------------------------------
%------------------------------------------------------------------------------
% File     : SET009^0 : TPTP v9.0.0. Released v3.6.0.
% Domain   : Set Theory
% Axioms   : Binary relations
% Version  : [Nei08] axioms.
% English  : Lots of stuff about binary relations. A binary relation is just
%            anything of type $i > $i > $o. Many properties and some proofs
%            can be found in chapter 2 of [BN99].

% Refs     : [BN99]  Baader & Nipkow (1999), Term Rewriting and All That
%          : [Nei08] Neis (2008), Email to Geoff Sutcliffe
% Source   : [Nei08]
% Names    : rel.ax [Nei08]

% Status   : Satisfiable
% Syntax   : Number of formulae    :   58 (  29 unt;  29 typ;  29 def)
%            Number of atoms       :   91 (  33 equ;   0 cnn)
%            Maximal formula atoms :    1 (   1 avg)
%            Number of connectives :  158 (   4   ~;   4   |;  12   &; 122   @)
%                                         (   0 <=>;  16  =>;   0  <=;   0 <~>)
%            Maximal formula depth :    1 (   1 avg; 122 nst)
%            Number of types       :    2 (   0 usr)
%            Number of type conns  :  197 ( 197   >;   0   *;   0   +;   0  <<)
%            Number of symbols     :   30 (  29 usr;   0 con; 1-3 aty)
%            Number of variables   :   86 (  43   ^  38   !;   5   ?;  86   :)
% SPC      : 

% Comments :
%------------------------------------------------------------------------------
%----BASICS
%----Subrelation
thf(subrel_type,type,
    subrel: ( $i > $i > $o ) > ( $i > $i > $o ) > $o ).

thf(subrel,definition,
    ( subrel
    = ( ^ [R: $i > $i > $o,S: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( R @ X @ Y )
         => ( S @ X @ Y ) ) ) ) ).

%----Inverse
thf(inv_type,type,
    inv: ( $i > $i > $o ) > $i > $i > $o ).

thf(inverse,definition,
    ( inv
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] : ( R @ Y @ X ) ) ) ).

%----IDEMPOTENCY, INFLATION, MONOTONICITY
%----Idempotency
thf(idem_type,type,
    idem: ( ( $i > $i > $o ) > $i > $i > $o ) > $o ).

thf(idempotent,definition,
    ( idem
    = ( ^ [F: ( $i > $i > $o ) > $i > $i > $o] :
        ! [R: $i > $i > $o] :
          ( ( F @ ( F @ R ) )
          = ( F @ R ) ) ) ) ).

%----Being inflationary
thf(infl_type,type,
    infl: ( ( $i > $i > $o ) > $i > $i > $o ) > $o ).

thf(inflationary,definition,
    ( infl
    = ( ^ [F: ( $i > $i > $o ) > $i > $i > $o] :
        ! [R: $i > $i > $o] : ( subrel @ R @ ( F @ R ) ) ) ) ).

%----Monotonicity
thf(mono_type,type,
    mono: ( ( $i > $i > $o ) > $i > $i > $o ) > $o ).

thf(monotonic,definition,
    ( mono
    = ( ^ [F: ( $i > $i > $o ) > $i > $i > $o] :
        ! [R: $i > $i > $o,S: $i > $i > $o] :
          ( ( subrel @ R @ S )
         => ( subrel @ ( F @ R ) @ ( F @ S ) ) ) ) ) ).

%----REFLEXIVITY, IRREFLEXIVITY, AND REFLEXIVE CLOSURE
%----Reflexivity
thf(refl_type,type,
    refl: ( $i > $i > $o ) > $o ).

thf(reflexive,definition,
    ( refl
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i] : ( R @ X @ X ) ) ) ).

%----Irreflexivity
thf(irrefl_type,type,
    irrefl: ( $i > $i > $o ) > $o ).

thf(irreflexive,definition,
    ( irrefl
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i] :
          ~ ( R @ X @ X ) ) ) ).

%----Reflexive closure
thf(rc_type,type,
    rc: ( $i > $i > $o ) > $i > $i > $o ).

thf(reflexive_closure,definition,
    ( rc
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] :
          ( ( X = Y )
          | ( R @ X @ Y ) ) ) ) ).

%----SYMMETRY, ANTISYMMETRY, ASYMMETRY, AND SYMMETRIC CLOSURE
%----Symmetry
thf(symm_type,type,
    symm: ( $i > $i > $o ) > $o ).

thf(symmetric,definition,
    ( symm
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( R @ X @ Y )
         => ( R @ Y @ X ) ) ) ) ).

%----Antisymmetry
thf(antisymm_type,type,
    antisymm: ( $i > $i > $o ) > $o ).

thf(antisymmetric,definition,
    ( antisymm
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( ( R @ X @ Y )
            & ( R @ Y @ X ) )
         => ( X = Y ) ) ) ) ).

%----Asymmetry
thf(asymm_type,type,
    asymm: ( $i > $i > $o ) > $o ).

thf(asymmetric,definition,
    ( asymm
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( R @ X @ Y )
         => ~ ( R @ Y @ X ) ) ) ) ).

%----Symmetric closure
thf(sc_type,type,
    sc: ( $i > $i > $o ) > $i > $i > $o ).

thf(symmetric_closure,definition,
    ( sc
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] :
          ( ( R @ Y @ X )
          | ( R @ X @ Y ) ) ) ) ).

%----TRANSITIVITY AND TRANSITIVE CLOSURE
%----Transitivity
thf(trans_type,type,
    trans: ( $i > $i > $o ) > $o ).

thf(transitive,definition,
    ( trans
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i,Z: $i] :
          ( ( ( R @ X @ Y )
            & ( R @ Y @ Z ) )
         => ( R @ X @ Z ) ) ) ) ).

%----Transitive closure
thf(tc_type,type,
    tc: ( $i > $i > $o ) > $i > $i > $o ).

% the transitive closure of R is the smallest transitive
% relation containing R (thanks, Chad!)
thf(transitive_closure,definition,
    ( tc
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] :
        ! [S: $i > $i > $o] :
          ( ( ( trans @ S )
            & ( subrel @ R @ S ) )
         => ( S @ X @ Y ) ) ) ) ).

%----TRANSITIVE REFLEXIVE CLOSURE AND TRANSITIVE REFLEXIVE SYMMETRIC CLOSURE
%----Transitive reflexive closure
thf(trc_type,type,
    trc: ( $i > $i > $o ) > $i > $i > $o ).

thf(transitive_reflexive_closure,definition,
    ( trc
    = ( ^ [R: $i > $i > $o] : ( rc @ ( tc @ R ) ) ) ) ).

%----Transitive reflexive symmetric closure
thf(trsc_type,type,
    trsc: ( $i > $i > $o ) > $i > $i > $o ).

thf(transitive_reflexive_symmetric_closure,definition,
    ( trsc
    = ( ^ [R: $i > $i > $o] : ( sc @ ( rc @ ( tc @ R ) ) ) ) ) ).

%----ORDERS
%----Being a partial order
thf(po_type,type,
    po: ( $i > $i > $o ) > $o ).

thf(partial_order,definition,
    ( po
    = ( ^ [R: $i > $i > $o] :
          ( ( refl @ R )
          & ( antisymm @ R )
          & ( trans @ R ) ) ) ) ).

%----Being a strict (partial) order
thf(so_type,type,
    so: ( $i > $i > $o ) > $o ).

thf(strict_order,definition,
    ( so
    = ( ^ [R: $i > $i > $o] :
          ( ( asymm @ R )
          & ( trans @ R ) ) ) ) ).

%----Totality
thf(total_type,type,
    total: ( $i > $i > $o ) > $o ).

thf(total,definition,
    ( total
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( X = Y )
          | ( R @ X @ Y )
          | ( R @ Y @ X ) ) ) ) ).

%----TERMINATION AND INDUCTION
%----Termination
thf(term_type,type,
    term: ( $i > $i > $o ) > $o ).

% axiomatisation: any non-empty subset has an R-maximal element
thf(terminating,definition,
    ( term
    = ( ^ [R: $i > $i > $o] :
        ! [A: $i > $o] :
          ( ? [X: $i] : ( A @ X )
         => ? [X: $i] :
              ( ( A @ X )
              & ! [Y: $i] :
                  ( ( A @ Y )
                 => ~ ( R @ X @ Y ) ) ) ) ) ) ).

%----Satisfying the induction principle
thf(ind_type,type,
    ind: ( $i > $i > $o ) > $o ).

thf(satisfying_the_induction_principle,definition,
    ( ind
    = ( ^ [R: $i > $i > $o] :
        ! [P: $i > $o] :
          ( ! [X: $i] :
              ( ! [Y: $i] :
                  ( ( tc @ R @ X @ Y )
                 => ( P @ Y ) )
             => ( P @ X ) )
         => ! [X: $i] : ( P @ X ) ) ) ) ).

%----NORMALIZATION
%----In normal form
thf(innf_type,type,
    innf: ( $i > $i > $o ) > $i > $o ).

thf(in_normal_form,definition,
    ( innf
    = ( ^ [R: $i > $i > $o,X: $i] :
          ~ ? [Y: $i] : ( R @ X @ Y ) ) ) ).

%----Normal form of
thf(nfof_type,type,
    nfof: ( $i > $i > $o ) > $i > $i > $o ).

thf(normal_form_of,definition,
    ( nfof
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] :
          ( ( trc @ R @ Y @ X )
          & ( innf @ R @ X ) ) ) ) ).

%----Normalization
thf(norm_type,type,
    norm: ( $i > $i > $o ) > $o ).

thf(normalizing,definition,
    ( norm
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i] :
        ? [Y: $i] : ( nfof @ R @ Y @ X ) ) ) ).

%----CONFLUENCE AND FRIENDS
%----Joinability
thf(join_type,type,
    join: ( $i > $i > $o ) > $i > $i > $o ).

thf(joinable,definition,
    ( join
    = ( ^ [R: $i > $i > $o,X: $i,Y: $i] :
        ? [Z: $i] :
          ( ( trc @ R @ X @ Z )
          & ( trc @ R @ Y @ Z ) ) ) ) ).

%----Local confluence
thf(lconfl_type,type,
    lconfl: ( $i > $i > $o ) > $o ).

thf(locally_confluent,definition,
    ( lconfl
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i,Z: $i] :
          ( ( ( R @ X @ Z )
            & ( R @ X @ Y ) )
         => ( join @ R @ Z @ Y ) ) ) ) ).

%----Semi confluence
thf(sconfl_type,type,
    sconfl: ( $i > $i > $o ) > $o ).

thf(semi_confluent,definition,
    ( sconfl
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i,Z: $i] :
          ( ( ( R @ X @ Z )
            & ( trc @ R @ X @ Y ) )
         => ( join @ R @ Z @ Y ) ) ) ) ).

%----Confluence
thf(confl_type,type,
    confl: ( $i > $i > $o ) > $o ).

thf(confluent,definition,
    ( confl
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i,Z: $i] :
          ( ( ( trc @ R @ X @ Z )
            & ( trc @ R @ X @ Y ) )
         => ( join @ R @ Z @ Y ) ) ) ) ).

%----Church-Rosser property
thf(cr_type,type,
    cr: ( $i > $i > $o ) > $o ).

thf(church_rosser,definition,
    ( cr
    = ( ^ [R: $i > $i > $o] :
        ! [X: $i,Y: $i] :
          ( ( trsc @ R @ X @ Y )
         => ( join @ R @ X @ Y ) ) ) ) ).

%------------------------------------------------------------------------------
